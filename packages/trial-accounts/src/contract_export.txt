### index.ts ###
// index.ts

/**
 * Main entry point for the Trial Accounts package.
 *
 * This package provides functions to deploy trial contracts,
 * create trials, add trial accounts, activate trial accounts,
 * perform actions, and broadcast transactions.
 *
 * @packageDocumentation
 */

export { TrialAccountManager } from "./lib/TrialAccountManager";
export { setupKeypomTrialSelector } from "./lib/wallet-selector/setup";

// Export types for user convenience
export * from "./lib/types";


### lib/validityChecker.ts ###
// lib/validityChecker.ts

import { ActionToPerform, TrialData, UsageStats } from "./types";
import { ExtEVMConstraints, NEARConstraints } from "./types/ChainConstraints";
import { TransactionData } from "./performAction";
import { parseNearAmount } from "near-api-js/lib/utils/format";

/**
 * Checks the validity of actions against trial data constraints.
 * @param actionsToPerform - The actions to validate.
 * @param trialData - The trial data containing constraints.
 * @param usageStats - Current usage statistics for the trial account.
 * @param currentTimestamp - The current timestamp in nanoseconds.
 * @throws Will throw an error if any action is invalid.
 */
export function checkActionValidity(
    actionsToPerform: ActionToPerform[],
    txnDatas: TransactionData[],
    trialData: TrialData,
    usageStats: UsageStats,
    currentTimestamp: number // in nanoseconds
): void {
    // Check if the trial has expired
    if (
        trialData.expirationTime &&
        currentTimestamp >= trialData.expirationTime
    ) {
        throw new Error("Trial period has expired");
    }

    const cumulativeUsageStats = { ...usageStats };

    let iterationCount = 0;
    for (const action of actionsToPerform) {
        const txnData = txnDatas[iterationCount];
        // Update total interactions
        cumulativeUsageStats.totalInteractions += 1;

        // Check transaction limit
        if (
            trialData.exitConditions &&
            trialData.exitConditions.transactionLimit
        ) {
            if (
                cumulativeUsageStats.totalInteractions >
                trialData.exitConditions.transactionLimit
            ) {
                throw new Error("Transaction limit reached");
            }
        }

        // Determine chain ID
        const chainId =
            action.chain === "NEAR" ? "NEAR" : action.chainId?.toString();
        if (!chainId) {
            throw new Error("Chain ID is missing for EVM action");
        }

        // Get constraints for the chain
        const constraints = trialData.constraintsByChainId[chainId];

        if (!constraints) {
            throw new Error(`No constraints defined for chain ${chainId}`);
        }

        // Now check action-specific constraints
        if (action.chain === "NEAR" && "allowedMethods" in constraints) {
            const nearConstraints = constraints as NEARConstraints;

            // Check if the method is allowed
            if (!nearConstraints.allowedMethods.includes(action.methodName)) {
                throw new Error(
                    `Method ${
                        action.methodName
                    } is not allowed on NEAR. Allowed methods: ${nearConstraints.allowedMethods.join()}`
                );
            }

            // Check if the contract is allowed
            if (
                !nearConstraints.allowedContracts.includes(
                    action.targetContractId
                )
            ) {
                throw new Error(
                    `Contract ${
                        action.targetContractId
                    } is not allowed on NEAR. Allowed contracts: ${nearConstraints.allowedContracts.join()}`
                );
            }

            // Check gas limit
            if (nearConstraints.maxGas && action.gas) {
                if (BigInt(action.gas) > BigInt(nearConstraints.maxGas)) {
                    throw new Error(
                        `Gas ${action.gas} exceeds maximum allowed ${nearConstraints.maxGas}`
                    );
                }
            }

            // Check deposit limit
            if (nearConstraints.maxDeposit && action.attachedDepositNear) {
                const actionDepositYocto = BigInt(
                    parseNearAmount(action.attachedDepositNear)!
                );
                if (actionDepositYocto > BigInt(nearConstraints.maxDeposit)) {
                    throw new Error(
                        `Deposit ${action.attachedDepositNear} exceeds maximum allowed ${nearConstraints.maxDeposit}`
                    );
                }
            }

            // Update usage statistics
            if (action.gas) {
                cumulativeUsageStats.gasUsed = (
                    BigInt(cumulativeUsageStats.gasUsed) + BigInt(action.gas)
                ).toString();
            }

            if (action.attachedDepositNear) {
                const actionDepositYocto = BigInt(
                    parseNearAmount(action.attachedDepositNear)!
                );
                cumulativeUsageStats.depositUsed = (
                    BigInt(cumulativeUsageStats.depositUsed) +
                    actionDepositYocto
                ).toString();
            }
        } else if (action.chain === "EVM" && "allowedMethods" in constraints) {
            const evmConstraints = constraints as ExtEVMConstraints;

            // Check if the method is allowed
            if (!evmConstraints.allowedMethods.includes(action.methodName)) {
                throw new Error(
                    `Method ${action.methodName} is not allowed on EVM. Allowed methods: ${evmConstraints.allowedMethods}`
                );
            }

            const isContractAllowed = !evmConstraints.allowedContracts.includes(
                action.targetContractId
            );
            if (!isContractAllowed) {
                throw new Error(
                    `Contract ${
                        action.targetContractId
                    } is not allowed on EVM. Allowed contracts: ${evmConstraints.allowedContracts.join()}`
                );
            }

            // Check gas limit
            if (evmConstraints.maxGas && txnData.gasLimit) {
                if (BigInt(txnData.gasLimit) > BigInt(evmConstraints.maxGas)) {
                    throw new Error(
                        `Gas limit ${txnData.gasLimit} exceeds maximum allowed ${evmConstraints.maxGas}`
                    );
                }
            }

            // Check value limit
            if (evmConstraints.maxValue && action.value) {
                if (BigInt(action.value) > BigInt(evmConstraints.maxValue)) {
                    throw new Error(
                        `Value ${action.value} exceeds maximum allowed ${evmConstraints.maxValue}`
                    );
                }
            }

            // Update usage statistics
            if (txnData.gasLimit) {
                cumulativeUsageStats.gasUsed = (
                    BigInt(cumulativeUsageStats.gasUsed) +
                    BigInt(txnData.gasLimit)
                ).toString();
            }

            if (action.value) {
                cumulativeUsageStats.depositUsed = (
                    BigInt(cumulativeUsageStats.depositUsed) +
                    BigInt(action.value)
                ).toString();
            }
        } else {
            throw new Error("Chain constraints mismatch or unsupported chain");
        }
        iterationCount += 1;
    }

    // After processing all actions, check if any usage constraints are exceeded
    if (trialData.usageConstraints) {
        const usageConstraints = trialData.usageConstraints;

        // Check maxTokenTransfer (assuming this refers to depositUsed)
        if (usageConstraints.maxTokenTransfer) {
            if (
                BigInt(cumulativeUsageStats.depositUsed) >
                BigInt(usageConstraints.maxTokenTransfer)
            ) {
                throw new Error("Deposit used exceeds maximum allowed");
            }
        }

        // Additional usage constraints can be added here
    }

    // Check interaction limits
    if (trialData.interactionLimits) {
        const interactionLimits = trialData.interactionLimits;

        // Check totalInteractions
        if (interactionLimits.totalInteractions) {
            if (
                cumulativeUsageStats.totalInteractions >
                interactionLimits.totalInteractions
            ) {
                throw new Error("Total interactions exceed maximum allowed");
            }
        }
    }

    // All checks passed
}


### lib/createTrial.ts ###
// lib/createTrial.ts

import { toSnakeCase, TrialData } from "./types";
import { ExtEVMConstraints, NEARConstraints } from "./types/ChainConstraints";

/**
 * Generates the arguments for creating a trial.
 *
 * @param params - The parameters required to create a trial.
 * @returns A Record containing the arguments for creating a trial.
 */
export function getCreateTrialParams(
    trialData: TrialData
): Record<string, any> {
    // Type guard to check if value is ExtEVMConstraints
    const isExtEVMConstraints = (
        value: NEARConstraints | ExtEVMConstraints
    ): value is ExtEVMConstraints => {
        return (value as ExtEVMConstraints).chainId !== undefined;
    };

    // Transform constraintsByChainId to use chain ID directly if it's EVM
    const transformedConstraints = Object.entries(
        trialData.constraintsByChainId
    ).reduce((acc, [key, value]) => {
        if (key === "EVM" && isExtEVMConstraints(value)) {
            // Now TypeScript knows that value is ExtEVMConstraints
            const evmConstraints = value;
            acc[evmConstraints.chainId] = { ...evmConstraints };
            acc[evmConstraints.chainId].initialDeposit =
                acc[evmConstraints.chainId].initialDeposit.toString();
            // @ts-ignore
            delete acc[evmConstraints.chainId].chainId; // Remove chainId as it's now used as the key
        } else {
            acc[key] = value;
        }
        return acc;
    }, {} as Record<string | number, NEARConstraints | ExtEVMConstraints>);

    const { constraintsByChainId, ...restTrialData } = trialData;

    const snakeCaseArgs = toSnakeCase({
        ...restTrialData,
        chain_constraints: transformedConstraints, // Use transformed constraints here
    });
    return snakeCaseArgs;
}


### lib/evmUtils.ts ###
import {
    ethers,
    Interface,
    JsonRpcProvider,
    ParamType,
    VoidSigner,
} from "ethers";
import { ActionToPerform } from "./types";
import {
    SerializableParam,
    SerializableToken,
    SerializableParamType,
} from "./types/EVMTypes";

export async function esimateGasParams(
    provider: JsonRpcProvider,
    signer: VoidSigner,
    actionToPerform: ActionToPerform
) {
    const nonce = await signer.getNonce();
    const destinationContract = new ethers.Contract(
        actionToPerform.targetContractId,
        actionToPerform.abi as any,
        provider
    );

    const actionFunction = destinationContract.getFunction(
        actionToPerform.methodName
    );
    const estimatedGas = await actionFunction.estimateGas(
        ...actionToPerform.args
    );

    const feeData = await provider.getFeeData();
    // 20% buffer
    const gasLimit = (estimatedGas * BigInt(12)) / BigInt(10);
    const maxPriorityFeePerGas =
        feeData.maxPriorityFeePerGas ?? ethers.parseUnits("50", "gwei");
    const maxFeePerGas =
        feeData.maxFeePerGas ?? ethers.parseUnits("10", "gwei");

    return {
        nonce,
        gasLimit,
        maxFeePerGas,
        maxPriorityFeePerGas,
    };
}

/**
 * Converts method name and arguments into SerializableParam[] and SerializableToken[].
 * @param methodName - The name of the method.
 * @param args - The arguments to the method.
 * @param abi - The ABI of the contract.
 * @returns An object containing methodParams and args in the required formats.
 */
export function encodeMethodParams(
    methodName: string,
    args: any[] | Record<string, any>,
    abi: any[]
): { methodParams: SerializableParam[]; args: SerializableToken[] } {
    // Find the ABI entry for the method
    const iface = new Interface(abi);
    const fragment = iface.getFunction(methodName);

    if (!fragment) {
        throw new Error(`Method ${methodName} not found in ABI`);
    }

    // Get the inputs from the ABI
    const inputs = fragment.inputs;

    // Convert inputs to SerializableParam[]
    const methodParams: SerializableParam[] = inputs.map((input: ParamType) => {
        return {
            name: input.name,
            kind: convertParamTypeToSerializableParamType(input.type),
        };
    });

    // Prepare the arguments
    let argValues: any[];
    if (Array.isArray(args)) {
        argValues = args;
    } else {
        // If args is an object, convert it to an array in the order of inputs
        argValues = inputs.map((input) => {
            if (!(input.name in args)) {
                throw new Error(`Argument ${input.name} is missing`);
            }
            return args[input.name];
        });
    }

    // Convert argValues to SerializableToken[]
    const argsTokens: SerializableToken[] = argValues.map((arg, index) => {
        const input = inputs[index];
        return convertValueToSerializableToken(input.type, arg);
    });

    return { methodParams, args: argsTokens };
}

/**
 * Converts a Solidity type string to a SerializableParamType.
 * @param type - The Solidity type string (e.g., 'uint256', 'address[]').
 * @returns The corresponding SerializableParamType.
 */
function convertParamTypeToSerializableParamType(
    type: string
): SerializableParamType {
    if (type.endsWith("[]")) {
        const innerType = type.slice(0, -2);
        return {
            type: "Array",
            value: convertParamTypeToSerializableParamType(innerType),
        };
    } else if (type === "address") {
        return { type: "Address" };
    } else if (type === "bytes") {
        return { type: "Bytes" };
    } else if (/^uint(\d+)?$/.test(type)) {
        const bits = type.slice(4) || "256";
        const value = parseInt(bits);
        return { type: "Uint", value };
    } else if (/^int(\d+)?$/.test(type)) {
        const bits = type.slice(3) || "256";
        const value = parseInt(bits);
        return { type: "Int", value };
    } else if (type === "bool") {
        return { type: "Bool" };
    } else if (type === "string") {
        return { type: "String" };
    } else if (/^bytes(\d+)$/.test(type)) {
        const value = parseInt(type.slice(5));
        return { type: "FixedBytes", value };
    } else {
        throw new Error(`Unsupported type: ${type}`);
    }
}

/**
 * Converts a value to a SerializableToken based on the Solidity type.
 * @param type - The Solidity type string.
 * @param value - The value to convert.
 * @returns The corresponding SerializableToken.
 */
function convertValueToSerializableToken(
    type: string,
    value: any
): SerializableToken {
    if (type.endsWith("[]")) {
        const innerType = type.slice(0, -2);
        if (!Array.isArray(value)) {
            throw new Error(`Expected array for type ${type}`);
        }
        const items = value.map((item) =>
            convertValueToSerializableToken(innerType, item)
        );
        return { type: "Array", value: items };
    } else if (type === "address") {
        return { type: "Address", value: value };
    } else if (type === "bytes") {
        return { type: "Bytes", value: value };
    } else if (/^uint(\d+)?$/.test(type)) {
        return { type: "Uint", value: value.toString() };
    } else if (/^int(\d+)?$/.test(type)) {
        return { type: "Int", value: value.toString() };
    } else if (type === "bool") {
        return { type: "Bool", value: value };
    } else if (type === "string") {
        return { type: "String", value: value };
    } else if (/^bytes(\d+)$/.test(type)) {
        return { type: "FixedBytes", value: value };
    } else {
        throw new Error(`Unsupported type: ${type}`);
    }
}


### lib/cryptoUtils.ts ###
// cryptoUtils.ts

import bs58 from "bs58";
import { sha256 } from "js-sha256";
import { Signature } from "near-api-js/lib/transaction";
import { KeyType } from "near-api-js/lib/utils/key_pair";

/**
 * Creates a NEAR Signature object from r, s, and recovery ID.
 * @param r - The r component of the signature.
 * @param s - The s component of the signature.
 * @returns A NEAR Signature object.
 */
export function createSignature(r: string, s: string): Signature {
    return new Signature({
        keyType: KeyType.SECP256K1,
        data: Buffer.concat([
            Buffer.from(r.substring(2), "hex"),
            Buffer.from(s, "hex"),
            Buffer.from(r.substring(0, 2), "hex"),
        ]),
    });
}

/**
 * Hashes the serialized transaction using SHA-256.
 * @param serializedTx - The serialized transaction bytes.
 * @returns The SHA-256 hash as a Uint8Array.
 */
export function hashTransaction(serializedTx: Uint8Array): Uint8Array {
    return new Uint8Array(sha256.array(serializedTx));
}

/**
 * Parses the NEAR public key from its string representation.
 * @param mpcPublicKey - The NEAR-formatted public key string.
 * @returns The decoded public key bytes.
 */
export function parsePublicKey(mpcPublicKey: string): Buffer {
    // Remove 'secp256k1:' prefix and decode
    const publicKeyBytes = bs58.decode(mpcPublicKey.replace("secp256k1:", ""));
    return Buffer.from(publicKeyBytes);
}


### lib/addTrialKeys.ts ###
// addTrialKeys.ts

import { KeyPair } from "near-api-js";
import { TrialKey } from "./types";

interface AddTrialAccountsParams {
    trialContractId: string;
    mpcContractId: string;
    numberOfKeys: number;
    viewFunction: any;
}

/**
 * Generates the trial key data needed to add trial accounts.
 *
 * @param params - The number of keys to generate.
 * @returns A Promise that resolves to an array of TrialKey objects.
 */
export async function generateTrialKeys(
    params: AddTrialAccountsParams
): Promise<TrialKey[]> {
    const { trialContractId, mpcContractId, numberOfKeys, viewFunction } =
        params;

    const trialKeys: TrialKey[] = [];

    for (let i = 0; i < numberOfKeys; i++) {
        // Generate a new key pair
        const keyPair = KeyPair.fromRandom("ed25519");

        // Derive the MPC public key
        const derivationPath = keyPair.getPublicKey().toString();

        const mpcPublicKey = await viewFunction({
            contractId: mpcContractId,
            methodName: "derived_public_key",
            args: {
                path: derivationPath,
                predecessor: trialContractId,
            },
        });

        trialKeys.push({
            derivationPath,
            trialAccountSecretKey: keyPair.toString(),
            trialAccountPublicKey: keyPair.getPublicKey().toString(),
            mpcKey: mpcPublicKey,
        });
    }

    return trialKeys;
}


### lib/broadcastTransaction.ts ###
// lib/broadcastTransaction.ts

import bs58 from "bs58";
import { createSignature } from "./cryptoUtils";
import { ActionToPerform, MPCSignature } from "./types";
import { logInfo, logSuccess } from "./logUtils";
import {
    ethers,
    getBytes,
    Interface,
    JsonRpcProvider,
    recoverAddress,
    Transaction,
    TransactionLike,
    TransactionResponse,
} from "ethers";
import { Near } from "near-api-js";
import { TransactionData } from "./performAction";
import { FinalExecutionOutcome } from "@near-wallet-selector/core";
import {
    Action,
    createTransaction,
    functionCall,
    SignedTransaction,
} from "near-api-js/lib/transaction";
import { parseNearAmount } from "near-api-js/lib/utils/format";
import { PublicKey } from "near-api-js/lib/utils";

interface BroadcastTransactionParams {
    nearConnection: Near;
    chainId: string;
    signerAccountId: string;
    actionToPerform: ActionToPerform;
    signatureResult: MPCSignature; // Signature result from the MPC
    txnData: TransactionData;
    mpcPublicKey: string;

    // EVM Specific
    providerUrl?: string;
}

/**
 * Broadcasts a signed transaction to the NEAR or EVM network.
 *
 * @param params - The parameters required to broadcast the transaction.
 * @returns A Promise that resolves when the transaction is broadcasted.
 * @throws Will throw an error if broadcasting fails.
 */
export async function broadcastTransaction(
    params: BroadcastTransactionParams
): Promise<{
    result: TransactionResponse | FinalExecutionOutcome;
    clientLog: any;
}> {
    const {
        nearConnection,
        signerAccountId,
        actionToPerform,
        signatureResult,
        providerUrl,
        chainId,
        txnData,
        mpcPublicKey,
    } = params;

    if (actionToPerform.chain === "NEAR") {
        if (signatureResult instanceof Uint8Array) {
            throw new Error("Signature result must be a string");
        }

        const { targetContractId, methodName, args, gas, attachedDepositNear } =
            actionToPerform;

        const serializedArgs = new Uint8Array(
            Buffer.from(JSON.stringify(args))
        );

        const signerAccount = await nearConnection.account(signerAccountId);
        const provider = signerAccount.connection.provider;

        const blockHashBytes = bs58.decode(txnData.blockHash!);

        const actions: Action[] = [
            functionCall(
                methodName,
                serializedArgs,
                BigInt(gas!),
                BigInt(parseNearAmount(attachedDepositNear!)!)
            ),
        ];

        const mpcPubKey = PublicKey.fromString(mpcPublicKey);
        const transaction = createTransaction(
            signerAccountId,
            mpcPubKey,
            targetContractId,
            txnData.nonce,
            actions,
            blockHashBytes
        );

        // Create the signature
        let r = signatureResult.big_r.affine_point;
        let s = signatureResult.s.scalar;

        const signature = createSignature(r, s);

        const signedTransaction = new SignedTransaction({
            transaction,
            signature,
        });

        // Send the signed transaction
        logInfo(`=== Sending NEAR Transaction ===`);
        const result = await provider.sendTransaction(signedTransaction);
        return { result, clientLog: "" };
    } else if (actionToPerform.chain === "EVM") {
        if (!providerUrl) {
            throw new Error("providerUrl is required for EVM transactions");
        }

        // Initialize provider
        const provider = new JsonRpcProvider(
            providerUrl,
            parseInt(chainId, 10)
        );

        // Encode function call data
        const contractInterface = new Interface(actionToPerform.abi);
        const functionData = contractInterface.getFunction(
            actionToPerform.methodName,
            actionToPerform.args as any[]
        );
        const data = contractInterface.encodeFunctionData(
            actionToPerform.methodName,
            actionToPerform.args as any[]
        );

        // Construct transaction data
        const transactionData: TransactionLike<string> = {
            nonce: parseInt(txnData.nonce, 10),
            gasLimit: BigInt(txnData.gasLimit),
            maxFeePerGas: BigInt(txnData.maxFeePerGas),
            maxPriorityFeePerGas: BigInt(txnData.maxPriorityFeePerGas),
            to: actionToPerform.targetContractId,
            data: data,
            value: BigInt(actionToPerform.value || "0"),
            chainId: parseInt(chainId, 10),
            type: 2, // EIP-1559 transaction
            accessList: actionToPerform.accessList || [],
        };

        // Create Transaction object
        const tx = Transaction.from(transactionData);

        // Get the serialized transaction
        const unsignedTx = tx.unsignedSerialized;
        const txHash = ethers.keccak256(unsignedTx);

        const payload = getBytes(txHash);

        // Log transaction information
        const clientLog = {};
        clientLog["Chain ID"] = parseInt(chainId, 10);
        clientLog["Nonce"] = parseInt(txnData.nonce, 10);
        clientLog["Max Priority Fee Per Gas"] = BigInt(
            txnData.maxPriorityFeePerGas
        ).toString();
        clientLog["Max Fee Per Gas"] = BigInt(txnData.maxFeePerGas).toString();
        clientLog["Gas Limit"] = BigInt(txnData.gasLimit || "0").toString();

        // Convert the contract address, input data, and hashed payload to arrays of numbers
        clientLog["Contract Address"] = hexStringToNumberArray(
            actionToPerform.targetContractId
        );
        clientLog["Value"] = BigInt(actionToPerform.value || "0").toString();
        clientLog["Input Data"] = hexStringToNumberArray(data);
        clientLog["Access List"] = actionToPerform.accessList || [];
        clientLog["Function"] = functionData; // This will stay as an object
        clientLog["ABI Parameters"] = contractInterface.getAbiCoder();
        clientLog["ABI Args"] = JSON.stringify(actionToPerform.args);
        clientLog["Hashed Payload"] = hexStringToNumberArray(txHash);
        clientLog["TXN Bytes"] = hexStringToNumberArray(unsignedTx);

        const sig = ethers.Signature.from({
            r:
                "0x" +
                signatureResult.big_r.affine_point.substring(2).toLowerCase(),
            s: "0x" + signatureResult.s.scalar.toLowerCase(),
            v: signatureResult.recovery_id,
        });
        tx.signature = sig;
        const recoveryAddress = recoverAddress(payload, sig);

        // Send the signed transaction
        logInfo(`=== Sending EVM Transaction ===`);
        if (recoveryAddress.toLowerCase() !== signerAccountId.toLowerCase()) {
            throw new Error(
                `Recovery address ${recoveryAddress} does not match signer address ${signerAccountId}`
            );
        } else {
            logSuccess(
                `Recovery address ${recoveryAddress} matches signer address ${signerAccountId}`
            );
        }

        logInfo(`Sending transaction from: ${recoveryAddress}`);
        const result = await provider.send("eth_sendRawTransaction", [
            tx.serialized,
        ]);
        return { result, clientLog };
    } else {
        throw new Error(`Unsupported chain type: ${actionToPerform.chain}`);
    }
}

// Helper function to convert hex string (e.g. "0x...") to an array of numbers
function hexStringToNumberArray(hexString) {
    if (hexString.startsWith("0x")) {
        hexString = hexString.slice(2);
    }
    const bytes = [];
    for (let i = 0; i < hexString.length; i += 2) {
        bytes.push(parseInt(hexString.substr(i, 2), 16));
    }
    return bytes;
}


### lib/logUtils.ts ###
// logUtils.ts

/**
 * ANSI escape codes for coloring console output.
 * These codes are widely supported in modern terminals.
 */

// Reset all attributes
const RESET = "\x1b[0m";

// Regular Colors
export const RED = "\x1b[31m";
const GREEN = "\x1b[32m";
const BLUE = "\x1b[34m";

/**
 * Logs a success message in green.
 * @param message - The message to log.
 */
export function logSuccess(message: string): void {
    console.log(`${GREEN}✅ ${message}${RESET}`);
}

/**
 * Logs an error message in red.
 * @param message - The message to log.
 */
export function logError(message: string): void {
    console.log(`${RED}❌ ${message}${RESET}`);
}

/**
 * Logs an informational message in blue.
 * @param message - The message to log.
 */
export function logInfo(message: string): void {
    console.log(`${BLUE}${message}${RESET}`);
}

/**
 * Extracts logs from the transaction result.
 * @param result - The transaction result object.
 * @returns An array of log strings.
 */
export function extractLogsFromResult(result: any): string[] {
    const logs: string[] = [];
    for (const outcome of result.receipts_outcome) {
        logs.push(...outcome.outcome.logs);
    }
    return logs;
}

export function parseContractLog(log: string): any {
    const parsedData: any = {};

    // Split log into lines and trim each line
    const lines = log.split("\n").map((line) => line.trim());

    // Iterate over each line and parse key and value
    for (const line of lines) {
        // Skip empty lines
        if (!line) continue;

        // Split the line into key and value
        const [key, ...rest] = line.split(":");
        const value = rest.join(":").trim(); // In case the value contains ':'

        if (key && value !== undefined) {
            switch (key) {
                case "LOG_STR_CHAIN_ID":
                    parsedData["Chain ID"] = value;
                    break;
                case "LOG_STR_NONCE":
                    parsedData["Nonce"] = value;
                    break;
                case "LOG_STR_MAX_PRIORITY_FEE_PER_GAS":
                    parsedData["Max Priority Fee Per Gas"] = value;
                    break;
                case "LOG_STR_MAX_FEE_PER_GAS":
                    parsedData["Max Fee Per Gas"] = value;
                    break;
                case "LOG_STR_GAS_LIMIT":
                    parsedData["Gas Limit"] = value;
                    break;
                case "LOG_STR_CONTRACT":
                    parsedData["Contract Address"] = parseArrayValue(value);
                    break;
                case "LOG_STR_VALUE":
                    parsedData["Value"] = value;
                    break;
                case "LOG_STR_INPUT":
                    parsedData["Input Data"] = parseArrayValue(value);
                    break;
                case "LOG_STR_ACCESS_LIST":
                    parsedData["Access List"] = parseArrayValue(value);
                    break;
                case "LOG_STR_FUNCTION":
                    parsedData["Function"] = value;
                    break;
                case "LOG_STR_ABI_PARAMS":
                    parsedData["ABI Parameters"] = value;
                    break;
                case "LOG_STR_ABI_ARGS":
                    parsedData["ABI Args"] = value;
                    break;
                case "LOG_STR_HASH":
                    parsedData["Hashed Payload"] = parseArrayValue(value);
                    break;
                case "LOG_STR_TXN_BYTES":
                    parsedData["Txn Bytes"] = parseArrayValue(value);
                    break;
                default:
                    // Unknown key; you might want to handle this
                    break;
            }
        }
    }

    return parsedData;
}

// Helper function to parse array-like strings
function parseArrayValue(value: string): number[] {
    // Remove brackets and any surrounding whitespace
    const trimmed = value.replace(/^\[|\]$/g, "").trim();
    if (!trimmed) return [];
    // Split by commas and parse each element to an integer
    return trimmed.split(",").map((s) => parseInt(s.trim(), 10));
}

/**
 * Parses the Actions string from a contract log.
 * @param actionsStr - The Actions string to parse.
 * @returns An array of parsed action objects.
 */
export function parseActionsString(actionsStr: string): any[] {
    const actions: any[] = [];

    const functionCallRegex =
        /FunctionCall\(FunctionCallAction \{ method_name: "(.*?)", args: (\[.*?\]), gas: U64\((\d+)\), deposit: U128\((\d+)\) \}\)/g;

    let match: any;
    while ((match = functionCallRegex.exec(actionsStr)) !== null) {
        actions.push({
            methodName: match[1],
            args: JSON.parse(match[2]),
            gas: match[3],
            deposit: match[4],
        });
    }

    return actions;
}


### lib/performAction.ts ###
// lib/performAction.ts

import { ActionToPerform, MPCSignature, TrialAccountInfo } from "./types";
import { encodeMethodParams, esimateGasParams } from "./evmUtils";
import { JsonRpcProvider, VoidSigner } from "ethers";
import { checkActionValidity } from "./validityChecker";
import { Near } from "near-api-js";
import { parseNearAmount } from "near-api-js/lib/utils/format";

export interface TransactionData {
    nonce: string;

    // For ETH
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    gasLimit?: string;

    // For NEAR
    blockHash?: string;
}

interface PerformActionsParams {
    near: Near;
    trialAccountInfo: TrialAccountInfo;
    actionsToPerform: ActionToPerform[];
    evmProviderUrl?: string;
}

/**
 * Performs one or more actions by requesting signatures from the MPC.
 *
 * @param params - The parameters required to perform actions.
 * @returns A Promise that resolves to an array of signature arrays.
 */
export async function generateActionArgs(
    params: PerformActionsParams
): Promise<{
    txnDatas: TransactionData[];
    txnArgs: any[];
}> {
    const { near, trialAccountInfo, actionsToPerform, evmProviderUrl } = params;

    const txnDatas: TransactionData[] = [];
    const txnArgs: any[] = [];
    for (const actionToPerform of actionsToPerform) {
        let chainId = actionToPerform.chainId || "NEAR";
        const trialAccountId = trialAccountInfo.accountIdByChainId[chainId];

        if (!trialAccountId) {
            throw new Error(`Trial account not activated for chain ${chainId}`);
        }

        if (actionToPerform.chain === "NEAR") {
            // Get the trial user's near account access key info to get the nonce
            let trialUserNearAccount = await near.account(trialAccountId);
            const accessKeys = await trialUserNearAccount.getAccessKeys();
            const accessKeyForSigning = accessKeys[0];

            // Transaction Data
            let nonce = accessKeyForSigning.access_key.nonce;
            const provider = trialUserNearAccount.connection.provider;
            const block = await provider.block({ finality: "final" });
            const blockHash = block.header.hash;

            nonce = BigInt(nonce) + 1n;
            const serializedArgs = Array.from(
                Buffer.from(JSON.stringify(actionToPerform.args))
            );

            const txnData: TransactionData = {
                nonce: nonce.toString(),
                blockHash,
            };
            // Check validity of actions
            checkActionValidity(
                [actionToPerform],
                [txnData],
                trialAccountInfo.trialData,
                trialAccountInfo.usageStats,
                Date.now()
            );

            txnDatas.push(txnData);
            txnArgs.push({
                contract_id: actionToPerform.targetContractId,
                method_name: actionToPerform.methodName,
                args: serializedArgs,
                gas: actionToPerform.gas,
                deposit: parseNearAmount(actionToPerform.attachedDepositNear!),
                nonce: nonce.toString(),
                block_hash: blockHash,
            });
        } else if (actionToPerform.chain === "EVM") {
            if (!actionToPerform.chainId) {
                throw new Error("chainId is not defined for EVM actions");
            }
            if (!evmProviderUrl) {
                throw new Error(
                    "evmProvider needs to be passed in for EVM actions"
                );
            }
            if (!actionToPerform.abi) {
                throw new Error("ABI is required for EVM actions");
            }

            // Use the utility function to encode method parameters
            const { methodParams, args } = encodeMethodParams(
                actionToPerform.methodName,
                actionToPerform.args!,
                actionToPerform.abi
            );

            // Initialize provider
            const provider = new JsonRpcProvider(
                evmProviderUrl,
                actionToPerform.chainId
            );

            // Get the nonce
            const signer = new VoidSigner(trialAccountId, provider);
            const { nonce, gasLimit, maxFeePerGas, maxPriorityFeePerGas } =
                await esimateGasParams(provider, signer, actionToPerform);

            // Check validity of actions
            const txnData: TransactionData = {
                nonce: nonce.toString(),
                gasLimit: gasLimit.toString(),
                maxFeePerGas: maxFeePerGas.toString(),
                maxPriorityFeePerGas: maxPriorityFeePerGas.toString(),
            };
            checkActionValidity(
                [actionToPerform],
                [txnData],
                trialAccountInfo.trialData,
                trialAccountInfo.usageStats,
                Date.now()
            );

            txnDatas.push(txnData);
            txnArgs.push({
                contract_address: actionToPerform.targetContractId,
                method_name: actionToPerform.methodName,
                method_params: methodParams,
                args: args,
                gas_limit: txnData.gasLimit,
                value: actionToPerform.value,
                chain_id: actionToPerform.chainId,
                nonce: txnData.nonce,
                max_fee_per_gas: txnData.maxFeePerGas,
                max_priority_fee_per_gas: txnData.maxPriorityFeePerGas,
                access_list: actionToPerform.accessList,
            });
        } else {
            throw new Error(`Unsupported chain type: ${actionToPerform.chain}`);
        }
    }

    return { txnDatas, txnArgs };
}

// Helper function to extract signature from the transaction result
export function extractSignatureFromResult(result: any): MPCSignature {
    const sigRes = JSON.parse(
        Buffer.from(result.status.SuccessValue, "base64").toString()
    );

    return sigRes;
}


### lib/TrialAccountManager.ts ###
// lib/TrialAccountManager.ts

import {
    ActionToPerform,
    TrialData,
    TrialKey,
    MPCSignature,
    convertKeysToCamelCase,
    TrialAccountInfo,
} from "./types";
import { getCreateTrialParams } from "./createTrial";
import { activateTrialAccounts } from "./activateTrial";
import { generateTrialKeys } from "./addTrialKeys";
import {
    extractSignatureFromResult,
    generateActionArgs,
    TransactionData,
} from "./performAction";
import { broadcastTransaction } from "./broadcastTransaction";
import {
    Wallet as SelectorWallet,
    NetworkId,
    FinalExecutionOutcome,
} from "@near-wallet-selector/core";
import {
    deriveChildPublicKey,
    najPublicKeyStrToUncompressedHexPoint,
    uncompressedHexPointToEvmAddress,
} from "./mpcUtils/kdf";
import { TransactionResponse } from "ethers";
import { sendTransaction } from "./networks/near";
import { Account, Near } from "near-api-js";
import { InMemoryKeyStore } from "near-api-js/lib/key_stores";
import { KeyPair, KeyPairString } from "near-api-js/lib/utils";

export type SigningAccount = Account | SelectorWallet;

/**
 * Class to manage trial accounts and trials.
 * Provides methods to create trials, add trial accounts,
 * activate trial accounts, perform actions, and broadcast transactions.
 */
export class TrialAccountManager {
    private trialContractId: string;
    private mpcContractId: string;
    private near: Near;

    private maxRetries: number;
    private initialDelayMs: number;
    private backoffFactor: number;

    /**
     * Constructs a new TrialAccountManager.
     * @param params - Parameters for initializing the manager.
     */
    constructor(params: {
        trialContractId: string;
        mpcContractId: string;
        networkId: NetworkId;
        maxRetries?: number;
        initialDelayMs?: number;
        backoffFactor?: number;
    }) {
        this.trialContractId = params.trialContractId;
        this.mpcContractId = params.mpcContractId;
        this.maxRetries = params.maxRetries ?? 3; // Default to 3 retries
        this.initialDelayMs = params.initialDelayMs ?? 1000; // Default to 1 second
        this.backoffFactor = params.backoffFactor ?? 2; // Default backoff factor of 2

        const near = new Near({
            networkId: params.networkId,
            nodeUrl: "https://rpc.testnet.near.org",
            keyStore: new InMemoryKeyStore(),
        });
        this.near = near;
    }

    /**
     * View function on the trial contract with retry logic.
     *
     * @param contractId - The ID of the contract to view.
     * @param methodName - The name of the method to view.
     * @param args - The arguments to pass to the method.
     *
     * @returns A Promise that resolves to the result of the view function.
     *
     * @throws Will throw an error if the view function fails.
     * @throws Will throw an error if the view function exceeds the maximum number of retries.
     */
    async viewFunction({ contractId, methodName, args }) {
        return retryAsync(
            async () => {
                const signerAccount = await this.near.account("foo");
                return await signerAccount.viewFunction({
                    contractId,
                    methodName,
                    args,
                });
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );
    }

    /**
     * Creates a new trial on the trial contract with retry logic.
     *
     * @param trialData - The trial data containing constraints.
     * @returns A Promise that resolves to the trial ID.
     */
    async createTrial({
        trialData,
        signingAccount,
    }: {
        trialData: TrialData;
        signingAccount: SigningAccount;
    }): Promise<number> {
        console.log("Creating trial...");
        console.log(trialData);
        const fnArgs = getCreateTrialParams(trialData);

        const result = await retryAsync(
            async () => {
                return await sendTransaction({
                    signerAccount: signingAccount,
                    receiverId: this.trialContractId,
                    methodName: "create_trial",
                    args: fnArgs,
                    deposit: "1",
                    gas: "300000000000000",
                });
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );

        const trialId = (result.status as any).SuccessValue
            ? parseInt(
                  Buffer.from(
                      (result.status as any).SuccessValue,
                      "base64"
                  ).toString(),
                  10
              )
            : null;
        if (trialId === null) {
            throw new Error("Failed to create trial");
        }

        return trialId;
    }

    /**
     * Adds trial accounts to the trial contract by generating key pairs with retry logic.
     *
     * @param numberOfKeys - Number of trial accounts to add.
     * @returns A Promise that resolves to an array of TrialKey objects.
     */
    async addTrialAccounts({
        trialId,
        numberOfKeys,
        signingAccount,
    }: {
        trialId: number;
        numberOfKeys: number;
        signingAccount: SigningAccount;
    }): Promise<TrialKey[]> {
        const trialKeys: TrialKey[] = await generateTrialKeys({
            trialContractId: this.trialContractId,
            mpcContractId: this.mpcContractId,
            numberOfKeys,
            viewFunction: this.viewFunction.bind(this),
        });

        // Prepare data to send to the contract
        const keysWithMpc = trialKeys.map((trialKey) => ({
            public_key: trialKey.trialAccountPublicKey,
            mpc_key: trialKey.mpcKey,
        }));

        const result = await retryAsync(
            async () => {
                // Call the `add_trial_keys` function
                return await sendTransaction({
                    signerAccount: signingAccount,
                    receiverId: this.trialContractId,
                    methodName: "add_trial_keys",
                    args: {
                        keys: keysWithMpc,
                        trial_id: trialId,
                    },
                    deposit: "1", // Adjust deposit as needed
                    gas: "300000000000000",
                });
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );

        if ((result.status as any).SuccessValue !== undefined) {
            return trialKeys;
        } else {
            throw new Error(
                `Failed to add trial accounts: ${JSON.stringify(result.status)}`
            );
        }
    }

    /**
     * Activates a trial account on the trial contract with retry logic.
     *
     * @param newAccountId - The account ID of the new trial account.
     * @returns A Promise that resolves when the account is activated.
     */
    async activateTrialAccounts({
        trialAccountSecretKey,
        newAccountId,
        chainId,
    }: {
        trialAccountSecretKey: KeyPairString;
        newAccountId: string;
        chainId?: string;
    }): Promise<void> {
        const trialAccountInfo = await this.getTrialData(trialAccountSecretKey);
        const trialAccountId = trialAccountInfo[chainId];
        if (trialAccountId) {
            throw new Error(
                "trial account is already activated. accountId: " +
                    trialAccountId
            );
        }

        return retryAsync(
            async () => {
                await activateTrialAccounts({
                    near: this.near,
                    trialContractId: this.trialContractId,
                    trialAccountIds: [newAccountId],
                    trialAccountSecretKeys: [trialAccountSecretKey],
                    chainIds: [chainId],
                });
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );
    }

    /**
     * Performs one or more actions by requesting signatures from the MPC with retry logic.
     *
     * @param actionsToPerform - Array of actions to perform.
     * @returns A Promise that resolves with signatures, nonces, and block hash.
     */
    async performActions({
        trialAccountSecretKey,
        actionsToPerform,
        evmProviderUrl,
    }: {
        trialAccountSecretKey: KeyPairString;
        actionsToPerform: ActionToPerform[];
        evmProviderUrl?: string;
    }): Promise<{
        signatures: MPCSignature[];
        txnDatas: TransactionData[];
        contractLogs?: string[];
    }> {
        const trialAccountInfo = await this.getTrialData(trialAccountSecretKey);

        const { txnArgs, txnDatas } = await generateActionArgs({
            near: this.near,
            trialAccountInfo,
            evmProviderUrl,
            actionsToPerform,
        });

        // Set the trial key in the keyStore
        const keyStore: any = (this.near.connection.signer as any).keyStore;
        await keyStore.setKey(
            this.near.connection.networkId,
            this.trialContractId,
            KeyPair.fromString(trialAccountSecretKey)
        );
        // set the signer to the trial contract to actually perform the call_*_contract methods using the proxy key
        const signerAccount = await this.near.account(this.trialContractId);

        const signatures = await retryAsync(
            async () => {
                const signatures: MPCSignature[] = [];
                let iter = 0;
                for (const actionToPerform of actionsToPerform) {
                    const args = txnArgs[iter];
                    if (actionToPerform.chain === "NEAR") {
                        // Call the perform_action method on the contract
                        const result = await sendTransaction({
                            signerAccount,
                            receiverId: this.trialContractId,
                            methodName: "call_near_contract",
                            args,
                            deposit: "0",
                            gas: "300000000000000",
                        });

                        // Extract the signature from the transaction result
                        const sigRes = extractSignatureFromResult(result);
                        signatures.push(sigRes);
                    } else if (actionToPerform.chain === "EVM") {
                        // Prepare the arguments as per the contract's expectations
                        const result = await sendTransaction({
                            signerAccount,
                            receiverId: this.trialContractId,
                            methodName: "call_evm_contract",
                            args,
                            deposit: "0",
                            gas: "300000000000000",
                        });

                        // Handle the result, extract signatures, etc.
                        const sigRes = extractSignatureFromResult(result);
                        signatures.push(sigRes);
                    }
                }
                iter++;
                return signatures;
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );

        return { signatures, txnDatas };
    }

    /**
     * Broadcasts a signed transaction to the NEAR or EVM network with retry logic.
     *
     * @param params - The parameters required to broadcast the transaction.
     * @returns A Promise that resolves when the transaction is broadcasted.
     */
    async broadcastTransaction(params: {
        trialAccountSecretKey: KeyPairString;
        actionToPerform: ActionToPerform;
        signatureResult: MPCSignature;
        providerUrl?: string;
        txnData: TransactionData;
    }): Promise<{
        result: TransactionResponse | FinalExecutionOutcome;
        clientLog: any;
    }> {
        const trialAccountInfo: TrialAccountInfo = await this.getTrialData(
            params.trialAccountSecretKey
        );
        const chainId = params.actionToPerform.chainId
            ? params.actionToPerform.chainId.toString()
            : "NEAR";

        const trialAccountId = trialAccountInfo.accountIdByChainId[chainId];
        if (!trialAccountId) {
            throw new Error(`No trial account found for chain ${chainId}`);
        }

        return retryAsync(
            async () => {
                return await broadcastTransaction({
                    nearConnection: this.near,
                    signerAccountId: trialAccountId,
                    actionToPerform: params.actionToPerform,
                    signatureResult: params.signatureResult,
                    providerUrl: params.providerUrl,
                    chainId,
                    txnData: params.txnData,
                    mpcPublicKey: trialAccountInfo.mpcKey,
                });
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );
    }

    /**
     * Retrieves the trial account info and converts it to camelCase with retry logic.
     *
     * @returns A Promise that resolves to the trial data in camelCase format.
     */
    async getTrialData(
        trialSecretKey: KeyPairString
    ): Promise<TrialAccountInfo> {
        return retryAsync(
            async () => {
                const trialPubKey = KeyPair.fromString(trialSecretKey)
                    .getPublicKey()
                    .toString();

                // Retrieve trial account info from the contract
                const trialAccountInfoSnakeCase = await this.viewFunction({
                    contractId: this.trialContractId,
                    methodName: "get_trial_account_info",
                    args: {
                        public_key: trialPubKey,
                    },
                });

                // Convert snake_case data to camelCase
                const trialAccountInfoCamelCase: TrialAccountInfo =
                    convertKeysToCamelCase(trialAccountInfoSnakeCase);

                return trialAccountInfoCamelCase;
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );
    }

    /**
     * Retrieves the account ID for the given chain ID
     *
     * @returns A Promise that resolves to the accountId
     */
    async getTrialAccountIdForChain(
        trialAccountSecretKey: KeyPairString,
        chainId: string
    ): Promise<string> {
        return retryAsync(
            async () => {
                const trialPubKey = KeyPair.fromString(trialAccountSecretKey)
                    .getPublicKey()
                    .toString();

                // Retrieve trial account info from the contract
                const trialAccountInfoSnakeCase = await this.viewFunction({
                    contractId: this.trialContractId,
                    methodName: "get_trial_account_info",
                    args: {
                        public_key: trialPubKey,
                    },
                });

                // Convert snake_case data to camelCase
                const trialAccountInfoCamelCase: TrialAccountInfo =
                    convertKeysToCamelCase(trialAccountInfoSnakeCase);

                return trialAccountInfoCamelCase.accountIdByChainId[chainId];
            },
            this.maxRetries,
            this.initialDelayMs,
            this.backoffFactor
        );
    }

    /**
     * Derives the ETH address from the passed in derivation path.
     * @param trialSecretKey - The secret key for the trial account.
     * @returns The ETH address.
     */
    async deriveEthAddress(trialSecretKey: KeyPairString): Promise<string> {
        const path = KeyPair.fromString(trialSecretKey)
            .getPublicKey()
            .toString();

        const rootKey = await this.viewFunction({
            contractId: this.mpcContractId,
            methodName: "public_key",
            args: {},
        });

        // Convert root public key to uncompressed hex point
        const rootUncompressedHexPoint =
            najPublicKeyStrToUncompressedHexPoint(rootKey);
        // Derive child public key using root public key, signerId, and path
        const derivedUncompressedHexPoint = deriveChildPublicKey(
            rootUncompressedHexPoint,
            this.trialContractId,
            path
        );
        // Convert derived public key to EVM address
        const evmAddressFromDerivedKey = uncompressedHexPointToEvmAddress(
            derivedUncompressedHexPoint
        );

        return evmAddressFromDerivedKey;
    }

    /**
     * Sets the retry logic configuration.
     * @param maxRetries - The maximum number of retries.
     * @param initialDelayMs - The initial delay between retries (in milliseconds).
     * @param backoffFactor - The backoff factor for exponential backoff.
     */
    setRetryConfig(
        maxRetries: number,
        initialDelayMs: number,
        backoffFactor: number
    ): void {
        this.maxRetries = maxRetries;
        this.initialDelayMs = initialDelayMs;
        this.backoffFactor = backoffFactor;
    }
}

/**
 * Helper function to retry an async operation with exponential backoff.
 *
 * @param fn - The async function to retry.
 * @param retries - Number of retries.
 * @param delay - Initial delay in milliseconds.
 * @param factor - Multiplicative factor for delay.
 * @returns The result of the async function if successful.
 * @throws The last error encountered if all retries fail.
 */
async function retryAsync<T>(
    fn: () => Promise<T>,
    retries: number = 3,
    delay: number = 1000,
    factor: number = 2
): Promise<T> {
    let attempt = 0;
    let currentDelay = delay;

    while (attempt < retries) {
        try {
            return await fn();
        } catch (error: any) {
            attempt++;
            if (attempt >= retries) {
                throw error;
            }
            console.warn(
                `Attempt ${attempt} failed. Retrying in ${currentDelay}ms...`,
                `Error: ${error.message || error}`
            );
            await new Promise((resolve) => setTimeout(resolve, currentDelay));
            currentDelay *= factor; // Exponential backoff
        }
    }

    // This point should never be reached
    throw new Error("Unexpected error in retryAsync");
}


### lib/activateTrial.ts ###
// activateTrial.ts

import { Near } from "near-api-js";
import { KeyPair, KeyPairString } from "near-api-js/lib/utils";
import { sendTransaction } from "./networks/near";

interface ActivateTrialAccountsParams {
    near: Near;
    trialContractId: string;
    trialAccountIds: string[];
    trialAccountSecretKeys: KeyPairString[];
    chainIds: string[];
}

/**
 * Activates trial accounts on the trial contract.
 *
 * @param params - The parameters required to activate trial accounts.
 * @returns A Promise that resolves when all accounts are activated.
 * @throws Will throw an error if activation of any trial account fails.
 */
export async function activateTrialAccounts(
    params: ActivateTrialAccountsParams
): Promise<void> {
    const { trialContractId, trialAccountIds, near, trialAccountSecretKeys } =
        params;

    for (let i = 0; i < trialAccountIds.length; i++) {
        const trialAccountId = trialAccountIds[i];
        const trialKey = trialAccountSecretKeys[i];
        const chainId = params.chainIds[i];

        // Set the trial key in the keyStore
        const keyStore: any = (near.connection.signer as any).keyStore;
        await keyStore.setKey(
            near.connection.networkId,
            trialContractId,
            KeyPair.fromString(trialKey)
        );
        const signerAccount = await near.account(trialContractId);

        const result = await sendTransaction({
            signerAccount,
            receiverId: trialContractId,
            methodName: "activate_trial",
            args: {
                new_account_id: trialAccountId,
                chain_id: chainId.toString(),
            },
            deposit: "0",
            gas: "300000000000000",
        });

        if (!result) {
            throw new Error(
                `Failed to activate trial account: ${trialAccountId}`
            );
        }
    }
}


### lib/wallet-selector/wallet.ts ###
import {
    FinalExecutionOutcome,
    InstantLinkWalletBehaviour,
    NetworkId,
    Transaction,
    VerifiedOwner,
    VerifyOwnerParams,
} from "@near-wallet-selector/core";
import { TrialAccountManager } from "../TrialAccountManager";
import { ActionToPerform, ChainType } from "../types";
import { KeyPairString } from "near-api-js/lib/utils";
import { FAILED_EXECUTION_OUTCOME } from "./types";
import { KeyType } from "near-api-js/lib/utils/key_pair";
import { isFinalExecutionOutcome } from "../networks/near";

export class KeypomTrialSelector implements InstantLinkWalletBehaviour {
    networkId: string;
    trialAccountSecretKey: KeyPairString;
    trialAccountId: string;
    trialManager: TrialAccountManager;

    constructor({
        networkId,
        trialAccountSecretKey,
        trialAccountId,
    }: {
        networkId: string;
        trialAccountSecretKey: KeyPairString;
        trialAccountId: string;
    }) {
        this.networkId = networkId;
        this.trialAccountSecretKey = trialAccountSecretKey;
        this.trialAccountId = trialAccountId;

        this.trialManager = new TrialAccountManager({
            trialContractId: "1729530318593-trial-contract.testnet",
            mpcContractId: "v1.signer-prod.testnet",
            networkId: this.networkId as NetworkId,
        });
    }

    verifyOwner(params: VerifyOwnerParams): Promise<void | VerifiedOwner> {
        const verifiedOwned: VerifiedOwner = {
            accountId: this.trialAccountId,
            message: "",
            blockId: "",
            publicKey: "",
            signature: "",
            keyType: KeyType.ED25519,
        };
        return Promise.resolve(verifiedOwned);
    }

    getContractId(): string {
        return "1729530318593-trial-contract.testnet";
    }

    getAccountId(): string {
        return this.trialAccountId;
    }

    isSignedIn(): boolean {
        return Boolean(this.trialAccountSecretKey);
    }

    async signAndSendTransaction(params: any) {
        console.log("Sign and send transaction", params);
        const actionToPerform: ActionToPerform = {
            chain: "NEAR" as ChainType,
            methodName: params.actions[0].params.methodName,
            args: params.actions[0].params.args,
            targetContractId: params.receiverId,
            attachedDepositNear: params.actions[0].params.deposit || "0",
            gas: params.actions[0].params.gas || "30000000000000",
        };
        console.log("Action to perform", actionToPerform);

        const { signatures, txnDatas } = await this.trialManager.performActions(
            {
                trialAccountSecretKey: this.trialAccountSecretKey,
                actionsToPerform: [actionToPerform],
            }
        );

        const result = await this.trialManager.broadcastTransaction({
            trialAccountSecretKey: this.trialAccountSecretKey,
            actionToPerform,
            signatureResult: signatures[0],
            txnData: txnDatas[0],
        });
        console.log("Result", result);

        return isFinalExecutionOutcome(result)
            ? (result as FinalExecutionOutcome)
            : FAILED_EXECUTION_OUTCOME;
    }

    async signAndSendTransactions(params: { transactions: Transaction[] }) {
        console.log("Sign and send transactions", params);
        const transactionResults: FinalExecutionOutcome[] = [];

        for (const tx of params.transactions) {
            if (tx.actions[0].type !== "FunctionCall") {
                throw new Error("Only function calls are supported");
            }

            const actionToPerform: ActionToPerform = {
                chain: "NEAR" as ChainType,
                methodName: tx.actions[0].params.methodName,
                args: tx.actions[0].params.args,
                targetContractId: tx.receiverId,
                attachedDepositNear: tx.actions[0].params.deposit || "0",
                gas: tx.actions[0].params.gas || "30000000000000",
            };
            console.log("Action to perform", actionToPerform);

            const { signatures, txnDatas } =
                await this.trialManager.performActions({
                    trialAccountSecretKey: this.trialAccountSecretKey,
                    actionsToPerform: [actionToPerform],
                });

            const result = await this.trialManager.broadcastTransaction({
                trialAccountSecretKey: this.trialAccountSecretKey,
                actionToPerform,
                signatureResult: signatures[0],
                txnData: txnDatas[0],
            });
            console.log("Result", result);

            if (isFinalExecutionOutcome(result)) {
                transactionResults.push(result as FinalExecutionOutcome);
            }
        }

        return transactionResults;
    }

    async signIn() {
        console.log("Signing in with trial account.");
        return [{ accountId: this.trialAccountId }];
    }

    async signOut() {
        console.log("Signing out trial account.");
        localStorage.removeItem("trialAccountSecretKey");
    }

    async getAvailableBalance() {
        return BigInt(0); // Placeholder for balance; requires API query for accurate info
    }

    async getAccounts() {
        return [{ accountId: this.trialAccountId }];
    }

    async switchAccount(id: string) {
        console.log("Switching accounts is not supported in this setup.");
    }
}


### lib/wallet-selector/setup.ts ###
import type {
    NetworkId,
    Transaction,
    WalletBehaviourFactory,
    WalletModuleFactory,
} from "@near-wallet-selector/core";
import { KeypomTrialSelector } from "./wallet";
import { KeypomWalletInstant, OneClickParams } from "./types";
import { TrialAccountManager } from "../TrialAccountManager";
import { KeyPairString } from "near-api-js/lib/utils";

interface KeypomInitializeOptions {
    keypomWallet: KeypomTrialSelector;
}

const Keypom: WalletBehaviourFactory<
    KeypomWalletInstant,
    KeypomInitializeOptions
> = async ({ store, logger, keypomWallet }) => {
    // return the wallet interface for wallet-selector
    return {
        get networkId() {
            return keypomWallet.networkId;
        },
        getContractId() {
            return keypomWallet.getContractId();
        },

        // async getAccount() {
        // 	return keypomWallet.getAccount();
        // },

        showModal() {
            return;
        },

        getAccounts() {
            logger.log("Keypom:account");
            return keypomWallet.getAccounts();
        },

        async switchAccount(id: string) {
            return await keypomWallet.switchAccount(id);
        },

        getAccountId() {
            logger.log("Keypom:getAccountId");
            return keypomWallet.getAccountId();
        },

        async isSignedIn() {
            logger.log("Keypom:isSignedIn");
            return keypomWallet.isSignedIn();
        },

        async getAvailableBalance() {
            logger.log("Keypom:isSignedIn");
            return await keypomWallet.getAvailableBalance();
        },

        async verifyOwner() {
            throw Error("KeypomWallet:verifyOwner is deprecated");
        },

        async signIn() {
            logger.log("Keypom:signIn");
            return await keypomWallet.signIn();
        },

        async signOut() {
            logger.log("Keypom:signOut");
            return await keypomWallet.signOut();
        },

        async signAndSendTransaction(params) {
            return await keypomWallet.signAndSendTransaction(params);
        },

        async signAndSendTransactions(params) {
            // Convert the params to Array<Transaction>

            const transactions: Transaction[] = params.transactions.map(
                (tx) => {
                    return {
                        ...tx,
                        signerId: tx.signerId || keypomWallet.getAccountId(),
                    };
                }
            );

            logger.log("Keypom:signAndSendTransactions", params);
            return await keypomWallet.signAndSendTransactions({ transactions });
        },
    };
};

export function setupKeypomTrialSelector(
    params: OneClickParams
): WalletModuleFactory<KeypomWalletInstant> {
    return async () => {
        const { networkId, contractId } = params;

        // Extract the trial account secret key from the URL parameters
        if (typeof window === undefined) {
            console.warn("window is undefined; aborting setup.");
            return null;
        }

        const urlParams = new URLSearchParams(window.location.search);
        const trialAccountSecretKey = urlParams.get("trialKey");

        if (!trialAccountSecretKey) {
            console.warn(
                "Missing trial account secret key in URL; aborting setup."
            );
            return null;
        }

        // Initialize TrialAccountManager with network information
        const trialManager = new TrialAccountManager({
            trialContractId: "1729530318593-trial-contract.testnet",
            mpcContractId: "v1.signer-prod.testnet",
            networkId: networkId as NetworkId,
        });

        // Fetch account ID using the trial manager and store it in memory
        const trialAccountId = await trialManager.getTrialAccountIdForChain(
            trialAccountSecretKey as KeyPairString,
            "NEAR"
        );
        // contract ID resetting, same with walletUrl
        const keypomWallet = new KeypomTrialSelector({
            networkId,
            trialAccountSecretKey: trialAccountSecretKey as KeyPairString,
            trialAccountId,
        });

        return {
            id: "keypom",
            type: "instant-link",
            metadata: {
                name: "Keypom Account",
                description: null,
                iconUrl: "",
                deprecated: false,
                available: true,
                contractId,
                runOnStartup: true,
            },
            init: async (config) =>
                Keypom({
                    ...config,
                    keypomWallet,
                }),
        };
    };
}


### lib/wallet-selector/types.ts ###
import { InstantLinkWallet, NetworkId } from "@near-wallet-selector/core";
import { KeypomTrialSelector } from "./wallet";

export const FAILED_EXECUTION_OUTCOME: any = {
    final_execution_status: "NONE",
    status: {
        Failure: {
            error_message: "Invalid Trial Action",
            error_type: "keypom-trial-error",
        },
    },
    transaction: {},
    transaction_outcome: {
        id: "",
        outcome: {
            logs: [],
            receipt_ids: [],
            tokens_burnt: "0",
            executor_id: "",
            gas_burnt: 0,
            status: {
                Failure: {
                    error_message: "Invalid Trial Action",
                    error_type: "keypom-trial-error",
                },
            },
        },
    },
    receipts_outcome: [
        {
            id: "",
            outcome: {
                logs: [],
                receipt_ids: [],
                gas_burnt: 0,
                tokens_burnt: "0",
                executor_id: "",
                status: {
                    Failure: {
                        error_message: "Invalid Trial Action",
                        error_type: "keypom-trial-error",
                    },
                },
            },
        },
    ],
};

export interface SignInOptions {
    contractId?: string;
    allowance?: string;
    methodNames?: string[];
}

export interface KeypomInitializeOptions {
    keypomWallet: KeypomTrialSelector;
}

export interface OneClickParams {
    networkId: NetworkId;
    contractId: string;
    allowance?: string;
    methodNames?: string[];
}

export const isOneClickParams = (params: OneClickParams): boolean =>
    typeof params.networkId === "string" &&
    (params.networkId === "testnet" || params.networkId === "mainnet");

export type KeypomWalletInstant = InstantLinkWallet & {
    networkId: string;
    getContractId(): string;
    switchAccount(id: string): Promise<void>;
    getAccountId(): string;
    isSignedIn: () => Promise<boolean>;
    getAvailableBalance: () => Promise<bigint>;
    showModal();
};

export type AddKeyPermission =
    | "FullAccess"
    | {
          receiverId: string;
          allowance?: string;
          methodNames?: Array<string>;
      };


### lib/types/ChainConstraints.ts ###
// lib/types/ChainConstraints.ts

export type ExtChainConstraints =
    | { NEAR: NEARConstraints }
    | { EVM: ExtEVMConstraints };

export interface NEARConstraints {
    allowedMethods: string[];
    allowedContracts: string[];
    maxGas: string | null;
    maxDeposit: string | null;
    initialDeposit: string;
}

export interface ExtEVMConstraints {
    chainId: number;
    allowedMethods: string[];
    allowedContracts: string[];
    maxGas: number | null;
    maxValue: string | null;
    initialDeposit: bigint;
}


### lib/types/MPCSignature.ts ###
/**
 * Result Type of MPC contract signature request.
 * Representing Affine Points on eliptic curve.
 * Example: {
    "big_r": {
      "affine_point": "031F2CE94AF69DF45EC96D146DB2F6D35B8743FA2E21D2450070C5C339A4CD418B"
    },
    "s": { "scalar": "5AE93A7C4138972B3FE8AEA1638190905C6DB5437BDE7274BEBFA41DDAF7E4F6"
    },
    "recovery_id": 0
  }
 */

export interface MPCSignature {
    big_r: { affine_point: string };
    s: { scalar: string };
    recovery_id: number;
}


### lib/types/Constraints.ts ###
// lib/types/Constraints.ts

/**
 * Specifies usage constraints like max contracts and methods.
 */
export interface UsageConstraints {
    maxContracts?: number;
    maxMethods?: number;
    maxTokenTransfer?: string; // U128 represented as a string
    rateLimitPerMinute?: number;
    blacklistedAddresses: string[]; // Use string to represent addresses for both NEAR and EVM
}

/**
 * Defines interaction limits for trial accounts.
 */
export interface InteractionLimits {
    maxInteractionsPerDay?: number;
    totalInteractions?: number;
}

/**
 * Represents a function success condition based on output.
 */
export interface FunctionSuccessCondition {
    contractId: string;
    methodName: string;
    expectedReturn: string;
}

/**
 * Conditions under which the trial account will exit.
 */
export interface ExitConditions {
    transactionLimit?: number;
    successCondition?: FunctionSuccessCondition;
    timeLimit?: number; // Timestamp in nanoseconds
}


### lib/types/BigInts.ts ###
export const BIGINT_27 = BigInt(27);
const BIGINT_0 = BigInt(0);

/*
 * A type that represents a `0x`-prefixed hex string.
 */
export type PrefixedHexString = `0x${string}`;

/**
 * Converts a {@link Uint8Array} to a {@link bigint}
 * @param {Uint8Array} bytes the bytes to convert
 * @returns {bigint}
 */
export const bytesToBigInt = (
    bytes: Uint8Array,
    littleEndian = false
): bigint => {
    if (littleEndian) {
        bytes.reverse();
    }
    const hex = bytesToHex(bytes);
    if (hex === "0x") {
        return BIGINT_0;
    }
    if (hex.length === 4) {
        // If the byte length is 1 (this is faster than checking `bytes.length === 1`)
        return BIGINT_CACHE[bytes[0]];
    }
    if (hex.length === 6) {
        return BIGINT_CACHE[bytes[0] * 256 + bytes[1]];
    }
    return BigInt(hex);
};

/****************  Borrowed from @chainsafe/ssz */
// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6
const hexByByte = Array.from({ length: 256 }, (_v, i) =>
    i.toString(16).padStart(2, "0")
);

export const bytesToHex = (bytes: Uint8Array): PrefixedHexString => {
    let hex: PrefixedHexString = `0x`;
    if (bytes === undefined || bytes.length === 0) return hex;
    for (const byte of bytes) {
        hex = `${hex}${hexByByte[byte]}`;
    }
    return hex;
};

// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)
const BIGINT_CACHE: bigint[] = [];
for (let i = 0; i <= 256 * 256 - 1; i++) {
    BIGINT_CACHE[i] = BigInt(i);
}


### lib/types/KeyData.ts ###
import { KeyPairString } from "near-api-js/lib/utils";

/**
 * Key data structure containing information about a trial key.
 */
export interface KeyData {
    publicKey: string;
    secretKey: string;
    trialId: number;
    mpcKey: string;
}

/**
 * Represents a trial key along with its associated account ID and MPC key.
 */
export interface TrialKey {
    derivationPath: string;
    trialAccountSecretKey: KeyPairString;
    trialAccountPublicKey: string;
    mpcKey: string;
}


### lib/types/TrialAccountInfo.ts ###
// lib/types/TrialAccountInfo.ts

import { TrialData } from "./TrialData";

/**
 * Usage statistics for the trial account.
 */
export interface UsageStats {
    interactionsPerDay: { [timestamp: number]: number }; // Day timestamp to interaction count
    totalInteractions: number;
    methodsCalled: { [methodName: string]: number }; // method_name to count
    contractsCalled: { [contractId: string]: number }; // contract_id to count
    gasUsed: string; // Represented as a string to handle large numbers
    depositUsed: string; // Represented as a string to handle large amounts
}

/**
 * Represents usage stats and account information for a trial account.
 */
export interface TrialAccountInfo {
    trialId: number;
    trialData: TrialData;
    mpcKey: string; // Corresponds to the public key in the Rust implementation
    accountIdByChainId: AccountIdByChainId;
    usageStats: UsageStats;
}

export type AccountIdByChainId = Record<string, string>;


### lib/types/Chain.ts ###
/**
 * Enum representing supported blockchains.
 */
export enum Chain {
    NEAR = "NEAR",
    Ethereum = "Ethereum",
}

export type ChainId = { type: "NEAR" } | { type: "EVM"; value: number };

export function serializeChainId(chainId: ChainId): any {
    if (chainId.type === "NEAR") {
        return { type: "NEAR" };
    } else if (chainId.type === "EVM") {
        return { type: "EVM", value: chainId.value };
    } else {
        throw new Error("Invalid ChainId");
    }
}

export function deserializeChainId(data: any): ChainId {
    if (data.type === "NEAR") {
        return { type: "NEAR" };
    } else if (data.type === "EVM") {
        return { type: "EVM", value: data.value };
    } else {
        throw new Error("Invalid ChainId data");
    }
}


### lib/types/util.ts ###
// lib/types/util.ts

// Utility to convert a string from snake_case to camelCase
export function snakeToCamel(str: string): string {
    return str.replace(/(_\w)/g, (m) => m[1].toUpperCase());
}

// Recursive function to convert all keys of an object from snake_case to camelCase
export function convertKeysToCamelCase(obj: any): any {
    if (Array.isArray(obj)) {
        return obj.map((item) => convertKeysToCamelCase(item));
    } else if (obj !== null && obj.constructor === Object) {
        return Object.keys(obj).reduce((result: any, key: string) => {
            const camelCaseKey = snakeToCamel(key);
            result[camelCaseKey] = convertKeysToCamelCase(obj[key]);
            return result;
        }, {});
    }
    return obj; // Return if neither object nor array
}

/**
 * Converts an object's keys from camelCase to snake_case recursively,
 * but keeps all-uppercase keys unchanged.
 *
 * @param obj - The object to be converted.
 * @returns The new object with snake_case keys.
 */
export function toSnakeCase(obj: any): any {
    if (Array.isArray(obj)) {
        return obj.map((item) => toSnakeCase(item));
    } else if (obj && typeof obj === "object" && obj.constructor === Object) {
        return Object.keys(obj).reduce((acc: any, key: string) => {
            // Check if the key is all uppercase
            const snakeKey = /^[A-Z0-9_]+$/.test(key)
                ? key
                : key.replace(/([A-Z])/g, "_$1").toLowerCase();
            acc[snakeKey] = toSnakeCase(obj[key]);
            return acc;
        }, {});
    }
    return obj;
}


### lib/types/index.ts ###
// lib/types/index.ts

export * from "./BigInts";
export * from "./EVMTypes";
export * from "./TrialAccountInfo";
export * from "./Constraints";
export * from "./ActionToPerform";
export * from "./TrialData";
export * from "./KeyData";
export * from "./MPCSignature";
export * from "./Chain";
export * from "./KeyUsage";
export * from "./util";


### lib/types/EVMTypes.ts ###
// lib/types/EVMTypes.ts

export interface SerializableParam {
    name: string;
    kind: SerializableParamType;
}

export type SerializableParamType =
    | { type: "Address" }
    | { type: "Bytes" }
    | { type: "Int"; value: number }
    | { type: "Uint"; value: number }
    | { type: "Bool" }
    | { type: "String" }
    | { type: "Array"; value: SerializableParamType }
    | { type: "FixedBytes"; value: number }
    | {
          type: "FixedArray";
          value: { inner: SerializableParamType; size: number };
      }
    | { type: "Tuple"; value: SerializableParamType[] };

export type SerializableToken =
    | { type: "Address"; value: string } // address as hex string
    | { type: "FixedBytes"; value: string } // hex string
    | { type: "Bytes"; value: string } // hex string
    | { type: "Int"; value: string } // value as string
    | { type: "Uint"; value: string } // value as string
    | { type: "Bool"; value: boolean }
    | { type: "String"; value: string }
    | { type: "FixedArray"; value: SerializableToken[] }
    | { type: "Array"; value: SerializableToken[] }
    | { type: "Tuple"; value: SerializableToken[] };

export interface AccessListItem {
    address: string; // hex string of the address
    storageKeys: string[]; // array of hex strings representing storage keys
}

export type AccessList = AccessListItem[];


### lib/types/TrialData.ts ###
// lib/types/TrialData.ts

import {
    UsageConstraints,
    InteractionLimits,
    ExitConditions,
} from "./Constraints";

import { ExtEVMConstraints, NEARConstraints } from "./ChainConstraints";

/**
 * Data required to create a trial.
 */
export interface TrialData {
    constraintsByChainId: {
        NEAR?: NEARConstraints;
        EVM?: ExtEVMConstraints;
    };
    usageConstraints: UsageConstraints | null;
    interactionLimits: InteractionLimits | null;
    exitConditions: ExitConditions | null;
    expirationTime: number | null;
    creatorAccountId?: string;
}


### lib/types/ActionToPerform.ts ###
// lib/types/ActionToPerform.ts

import { AccessList } from "./EVMTypes";

export interface ActionToPerform {
    chain: ChainType;
    methodName: string;
    args?: any[] | Record<string, any>; // Simplify args input
    abi?: any[]; // Optionally provide ABI
    value?: string; // For EVM, represented as a string
    chainId?: number; // For EVM, represented as a number
    accessList?: AccessList; // Updated type
    targetContractId: string; // For EVM, this would be the contract address
    attachedDepositNear?: string; // For NEAR, represented as a string
    gas?: string; // For NEAR, represented as a string
}

export type ChainType = "NEAR" | "EVM";


### lib/types/KeyUsage.ts ###
import { AccountIdByChainId, UsageStats } from "./TrialAccountInfo";

/**
 * Associates a public key with its usage stats and trial ID.
 */
export interface KeyUsage {
    trialId: number;
    mpcKey: string; // PublicKey represented as a string
    accountId: AccountIdByChainId;
    usageStats: UsageStats;
}

/**
 * Structure representing a key with both a public key and MPC key.
 */
export interface KeyWithMPC {
    publicKey: string; // PublicKey represented as a string
    mpcKey: string; // MPC PublicKey represented as a string
}


### lib/networks/near.ts ###
// networks/utils.ts

import { SigningAccount } from "../TrialAccountManager";
import {
    Action as WalletAction,
    FinalExecutionOutcome,
} from "@near-wallet-selector/core";
import {
    Action,
    functionCall,
    FunctionCallPermission,
} from "near-api-js/lib/transaction";
import { parseNearAmount } from "near-api-js/lib/utils/format";
import { Account } from "near-api-js";

export async function sendTransaction({
    signerAccount,
    receiverId,
    methodName,
    args,
    deposit,
    gas,
}: {
    signerAccount: SigningAccount;
    receiverId: string;
    methodName: string;
    args: any;
    deposit: string;
    gas: string;
}): Promise<FinalExecutionOutcome> {
    const serializedArgsBuffer = Buffer.from(JSON.stringify(args));
    const serializedArgs = new Uint8Array(serializedArgsBuffer);

    let actions: Action[] = [];

    actions.push(
        functionCall(
            methodName,
            serializedArgs,
            BigInt(gas),
            BigInt(parseNearAmount(deposit)!)
        )
    );

    let result: any;
    console.log("Signer account", signerAccount);
    if (isAccount(signerAccount)) {
        console.log("is Account");
        result = await signerAccount.signAndSendTransaction({
            receiverId: receiverId,
            actions,
        });
    } else {
        console.log("actions", actions);
        try {
            const transformedActions =
                transformAccountActionsToWalletActions(actions);
            console.log("transformedActions", transformedActions);
            result = await signerAccount.signAndSendTransaction({
                receiverId: receiverId,
                actions: transformedActions,
            });
        } catch (error) {
            console.log("error", error);
            const transformedActions =
                transformAccountActionsToWalletActionsLatest(actions);
            console.log("transformedActions", transformedActions);
            result = await signerAccount.signAndSendTransaction({
                receiverId: receiverId,
                actions: transformedActions,
            });
        }
    }

    return result;
}

function isAccount(account: any): account is Account {
    return account instanceof Account;
}

// Function to transform AccountActions to WalletActions
function transformAccountActionsToWalletActions(
    accountActions: Action[]
): WalletAction[] {
    return accountActions.map((action) => {
        switch (action.enum) {
            case "createAccount":
                return {
                    type: "CreateAccount",
                };
            case "deployContract":
                return {
                    type: "DeployContract",
                    params: {
                        code: action.deployContract!.code,
                    },
                };
            case "functionCall":
                return {
                    type: "FunctionCall",
                    params: {
                        methodName: action.functionCall!.methodName,
                        args: JSON.parse(
                            Buffer.from(action.functionCall!.args).toString(
                                "utf8"
                            )
                        ),
                        gas: action.functionCall!.gas.toString(),
                        deposit: action.functionCall!.deposit.toString(),
                    },
                };
            case "transfer":
                return {
                    type: "Transfer",
                    params: {
                        deposit: action.transfer!.deposit.toString(),
                    },
                };
            case "stake":
                return {
                    type: "Stake",
                    params: {
                        stake: action.stake!.stake.toString(),
                        publicKey: action.stake!.publicKey.toString(),
                    },
                };
            case "addKey":
                return {
                    type: "AddKey",
                    params: {
                        publicKey: action.addKey!.publicKey.toString(),
                        accessKey: {
                            permission:
                                action.addKey!.accessKey.permission instanceof
                                FunctionCallPermission
                                    ? {
                                          receiverId:
                                              action.addKey!.accessKey
                                                  .permission.receiverId,
                                          allowance:
                                              action.addKey!.accessKey.permission.allowance?.toString(),
                                          methodNames:
                                              action.addKey!.accessKey
                                                  .permission.methodNames,
                                      }
                                    : "FullAccess",
                        },
                    },
                };
            case "deleteKey":
                return {
                    type: "DeleteKey",
                    params: {
                        publicKey: action.deleteKey!.publicKey.toString(),
                    },
                };
            case "deleteAccount":
                return {
                    type: "DeleteAccount",
                    params: {
                        beneficiaryId: action.deleteAccount!.beneficiaryId,
                    },
                };
            default:
                throw new Error(`Unsupported action type: ${action.enum}`);
        }
    });
}

// Utility to serialize args for function calls
function serializeArgs(args: any): Uint8Array {
    if (typeof args === "object") {
        return new Uint8Array(Buffer.from(JSON.stringify(args)));
    }
    return args;
}

// Function to transform AccountActions to WalletActions
function transformAccountActionsToWalletActionsLatest(
    accountActions: Action[]
): any[] {
    return accountActions.map((action) => {
        switch (action.enum) {
            case "createAccount":
                return {
                    type: "createAccount",
                };
            case "deployContract":
                return {
                    type: "deployContract",
                    params: {
                        code: action.deployContract!.code,
                    },
                };
            case "functionCall":
                return {
                    type: "functionCall",
                    params: {
                        methodName: action.functionCall!.methodName,
                        args: serializeArgs(action.functionCall!.args),
                        gas: action.functionCall!.gas.toString(),
                        deposit: action.functionCall!.deposit.toString(),
                    },
                };
            case "transfer":
                return {
                    type: "transfer",
                    params: {
                        deposit: action.transfer!.deposit.toString(),
                    },
                };
            case "stake":
                return {
                    type: "stake",
                    params: {
                        stake: action.stake!.stake.toString(),
                        publicKey: action.stake!.publicKey.toString(),
                    },
                };
            case "addKey":
                return {
                    type: "addKey",
                    params: {
                        publicKey: action.addKey!.publicKey.toString(),
                        accessKey: {
                            permission:
                                action.addKey!.accessKey.permission instanceof
                                FunctionCallPermission
                                    ? {
                                          receiverId:
                                              action.addKey!.accessKey
                                                  .permission.receiverId,
                                          allowance:
                                              action.addKey!.accessKey.permission.allowance?.toString(),
                                          methodNames:
                                              action.addKey!.accessKey
                                                  .permission.methodNames,
                                      }
                                    : "FullAccess",
                        },
                    },
                };
            case "deleteKey":
                return {
                    type: "deleteKey",
                    params: {
                        publicKey: action.deleteKey!.publicKey.toString(),
                    },
                };
            case "deleteAccount":
                return {
                    type: "deleteAccount",
                    params: {
                        beneficiaryId: action.deleteAccount!.beneficiaryId,
                    },
                };
            default:
                throw new Error(`Unsupported action type: ${action.enum}`);
        }
    });
}

export function isFinalExecutionOutcome(
    result: any
): result is FinalExecutionOutcome {
    return (
        result &&
        typeof result === "object" &&
        "final_execution_status" in result &&
        "status" in result &&
        "transaction" in result &&
        "transaction_outcome" in result &&
        "receipts_outcome" in result
    );
}


### lib/networks/types.ts ###
import {
    Address,
    Hex,
    SignableMessage,
    Signature,
    TransactionSerializable,
    TypedDataDomain,
} from "viem";

/**
 * Represents the base transaction structure.
 *
 * @property {`0x${string}`} to - Recipient of the transaction.
 * @property {bigint} [value] - ETH value of the transaction.
 * @property {`0x${string}`} data - Call data of the transaction.
 * @property {number} chainId - Integer ID of the network for the transaction.
 * @property {number} [nonce] - Specified transaction nonce.
 * @property {bigint} [gas] - Optional gas limit.
 */
export interface BaseTx {
    to: `0x${string}`;
    value?: bigint;
    data?: `0x${string}`;
    chainId: number;
    nonce?: number;
    gas?: bigint;
}

/**
 * Represents the gas fees for an Ethereum transaction.
 *
 * @property {bigint} maxFeePerGas - The maximum fee per gas unit.
 * @property {bigint} maxPriorityFeePerGas - The maximum priority fee per gas unit.
 */
export interface GasFees {
    maxFeePerGas: bigint;
    maxPriorityFeePerGas: bigint;
}

/**
 * Represents the data for a message.
 *
 * @property {Hex} address - The address associated with the message.
 * @property {SignableMessage} message - The signable message.
 */
export interface MessageData {
    address: Hex;
    message: SignableMessage;
}

interface TypedDataTypes {
    name: string;
    type: string;
}
type TypedMessageTypes = {
    [key: string]: TypedDataTypes[];
};

/**
 * Represents the data for a typed message.
 *
 * @property {TypedDataDomain} domain - The domain of the message.
 * @property {TypedMessageTypes} types - The types of the message.
 * @property {Record<string, unknown>} message - The message itself.
 * @property {string} primaryType - The primary type of the message.
 */
export type EIP712TypedData = {
    domain: TypedDataDomain;
    types: TypedMessageTypes;
    message: Record<string, unknown>;
    primaryType: string;
};

/**
 * Represents the recovery data.
 *
 * @property {string} type - The type of the recovery data.
 * @property {MessageData | EIP712TypedData | Hex} data - The recovery data.
 */
export interface RecoveryData {
    // TODO use enum!
    type: string;
    data: MessageData | EIP712TypedData | Hex;
}

/**
 * Sufficient data required to construct a signed Ethereum Transaction.
 *
 * @property {Hex} transaction - Unsigned Ethereum transaction data.
 * @property {Signature} signature - Representation of the transaction's signature.
 */
export interface TransactionWithSignature {
    transaction: Hex;
    signature: Signature;
}

/// Below is hand-crafted types losely related to wallet connect

/**
 * Interface representing the parameters required for an Ethereum transaction.
 *
 * @property {Hex} from - The sender's Ethereum address in hexadecimal format.
 * @property {Hex} to - The recipient's Ethereum address in hexadecimal format.
 * @property {Hex} [gas] - Optional gas limit for the transaction in hexadecimal format.
 * @property {Hex} [value] - Optional amount of Ether to send in hexadecimal format.
 * @property {Hex} [data] - Optional data payload for the transaction in hexadecimal format, often used for contract interactions. */
export interface EthTransactionParams {
    from: Hex;
    to: Hex;
    gas?: Hex;
    value?: Hex;
    data?: Hex;
}

/**
 * Type representing the parameters for a personal_sign request.
 *
 * @type {[Hex, Address]}
 * @property {Hex} 0 - The message to be signed in hexadecimal format.
 * @property {Address} 1 - The address of the signer in hexadecimal format.
 */
export type PersonalSignParams = [Hex, Address];

/**
 * Type representing the parameters for an eth_sign request.
 *
 * @type {[Address, Hex]}
 * @property {Address} 0 - The address of the signer in hexadecimal format.
 * @property {Hex} 1 - The message to be signed in hexadecimal format.
 */
export type EthSignParams = [Address, Hex];

/**
 * Type representing the parameters for signing complex structured data (like EIP-712).
 *
 * @type {[Hex, string]}
 * @property {Hex} 0 - The address of the signer in hexadecimal format.
 * @property {string} 1 - The structured data in JSON string format to be signed.
 */
export type TypedDataParams = [Hex, string];

/**
 * Type representing the possible request parameters for a signing session.
 *
 * @type {EthTransactionParams[] | Hex | PersonalSignParams | EthSignParams | TypedDataParams}
 * @property {EthTransactionParams[]} - An array of Ethereum transaction parameters.
 * @property {Hex} - A simple hexadecimal value representing RLP Encoded Ethereum Transaction.
 * @property {PersonalSignParams} - Parameters for a personal sign request.
 * @property {EthSignParams} - Parameters for an eth_sign request.
 * @property {TypedDataParams} - Parameters for signing structured data.
 */
export type SessionRequestParams =
    | EthTransactionParams[]
    | Hex
    | PersonalSignParams
    | EthSignParams
    | TypedDataParams;

/**
 * An array of supported signing methods.
 */
export const signMethods = [
    "eth_sign",
    "personal_sign",
    "eth_sendTransaction",
    "eth_signTypedData",
    "eth_signTypedData_v4",
] as const;

/**
 * Type representing one of the supported signing methods.
 */
export type SignMethod = (typeof signMethods)[number];

/**
 * Interface representing the data required for a signature request.
 *
 * @property {SignMethods} method - The signing method to be used.
 * @property {number} chainId - The ID of the Ethereum chain where the transaction or signing is taking place.
 * @property {SessionRequestParams} params - The parameters required for the signing request, which vary depending on the method.
 */
export type SignRequestData = {
    method: SignMethod;
    chainId: number;
    params: SessionRequestParams;
};


### lib/networks/constants.ts ###
// from https://github.com/BitteProtocol/near-ca/blob/main/src/network/constants.ts
interface ChainInfo {
    currencyIcon?: string;
    icon?: string;
    wrappedToken: string;
}

/// A short list of networks with known wrapped tokens.

const DATA_IMG = "data:image/svg+xml;base64,";


export const CHAIN_INFO: Record<number, ChainInfo> = {
    // Ethereum Mainnet
    1: {
        currencyIcon: ETHER,
        icon: ETHEREUM_ICON,
        wrappedToken: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    },
    // Optimism
    10: {
        currencyIcon: ETHER,
        icon: OPTIMISM_ICON,
        wrappedToken: "0x4200000000000000000000000000000000000006",
    },
    // Binance Smart Chain
    56: {
        icon: BINANCE_ICON,
        wrappedToken: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    },
    // Binance Testnet
    97: {
        icon: BINANCE_ICON,
        wrappedToken: "0x094616f0bdfb0b526bd735bf66eca0ad254ca81f",
    },
    // Gnosis Chain
    100: {
        currencyIcon: XDAI,
        icon: GNOSIS_ICON,
        wrappedToken: "0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1",
    },
    // Polygon
    137: {
        icon: POLYGON_ICON,
        currencyIcon: POL,
        wrappedToken: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
    },
    // Base
    8453: {
        currencyIcon: ETHER,
        icon: BASE_ICON,
        wrappedToken: "0x4200000000000000000000000000000000000006",
    },
    // Gnosis Chiado Testnet
    10200: {
        currencyIcon: XDAI,
        icon: GNOSIS_ICON,
        wrappedToken: "0xb2D0d7aD1D4b2915390Dc7053b9421F735A723E7",
    },
    // Arbitrum
    42161: {
        currencyIcon: ETHER,
        icon: ARBITRUM_ICON,
        wrappedToken: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
    },
    // Base Sepolia
    84532: {
        currencyIcon: ETHER,
        icon: BASE_ICON,
        wrappedToken: "0x4200000000000000000000000000000000000006",
    },
    // Arbitrum Sepolia
    421614: {
        currencyIcon: ETHER,
        icon: ARBITRUM_ICON,
        wrappedToken: "0x980b62da83eff3d4576c647993b0c1d7faf17c73",
    },
    // Sepolia
    11155111: {
        currencyIcon: ETHER,
        icon: ETHEREUM_ICON,
        wrappedToken: "0xD0A1E359811322d97991E03f863a0C30C2cF029C",
    },
};


### lib/networks/index.ts ###
// from https://github.com/BitteProtocol/near-ca/blob/main/src/network/index.ts
//
import { createPublicClient, http, PublicClient } from "viem";
import * as chains from "viem/chains";
import { CHAIN_INFO } from "./constants";

// We support all networks exported by viem
const SUPPORTED_NETWORKS = createNetworkMap(Object.values(chains));

export interface NetworkFields {
    name: string;
    rpcUrl: string;
    chainId: number;
    scanUrl: string;
    icon: string | undefined;
    testnet: boolean;
    nativeCurrency: {
        decimals: number;
        name: string;
        symbol: string;
        wrappedAddress: string | undefined;
        // This is often Network logo, but sometimes not (e.g. Gnosis Chain & xDai)
        icon: string | undefined;
    };
}
/**
 * Leveraging Network Data provided from through viem
 * This class makes all relevant network fields accessible dynamically by chain ID.
 */
export class Network implements NetworkFields {
    name: string;
    rpcUrl: string;
    chainId: number;
    scanUrl: string;
    client: PublicClient;
    icon: string | undefined;
    testnet: boolean;
    nativeCurrency: {
        decimals: number;
        name: string;
        symbol: string;
        wrappedAddress: string | undefined;
        icon: string | undefined;
    };

    constructor({
        name,
        rpcUrl,
        chainId,
        scanUrl,
        nativeCurrency,
        icon,
    }: NetworkFields) {
        const network = SUPPORTED_NETWORKS[chainId]!;

        this.name = name;
        this.rpcUrl = rpcUrl;
        this.chainId = chainId;
        this.scanUrl = scanUrl;
        this.client = createPublicClient({
            transport: http(network.rpcUrl),
        });
        this.testnet = network.testnet;
        this.nativeCurrency = nativeCurrency;
        this.icon = icon;
    }

    static fromChainId(chainId: number): Network {
        const networkFields = SUPPORTED_NETWORKS[chainId];
        if (!networkFields) {
            throw new Error(
                `Network with chainId ${chainId} is not supported.
        Please reach out to the developers of https://github.com/Mintbase/near-ca`
            );
        }
        return new Network(networkFields);
    }
}

type NetworkMap = { [key: number]: NetworkFields };

/// Dynamically generate network map accessible by chainId.
function createNetworkMap(supportedNetworks: any): NetworkMap {
    const networkMap: NetworkMap = {};
    supportedNetworks.forEach((network) => {
        const chainInfo = CHAIN_INFO[network.id];
        const icon = chainInfo?.icon || `/${network.nativeCurrency.symbol}.svg`;
        networkMap[network.id] = {
            name: network.name,
            rpcUrl: network.rpcUrls.default.http[0]!,
            chainId: network.id,
            scanUrl: network.blockExplorers?.default.url || "",
            icon,
            testnet: network.testnet || false,
            nativeCurrency: {
                ...network.nativeCurrency,
                wrappedAddress: chainInfo?.wrappedToken,
                icon: chainInfo?.currencyIcon || icon,
            },
        };
    });

    return networkMap;
}

export function isTestnet(chainId: number): boolean {
    return Network.fromChainId(chainId).testnet;
}


### lib/networks/evm.ts ###
import {
    Hash,
    Hex,
    keccak256,
    parseTransaction,
    serializeTransaction,
} from "viem";
import { Network } from ".";
import { TransactionWithSignature } from "./types";

export function addSignature({
    transaction,
    signature,
}: TransactionWithSignature): Hex {
    // @ts-ignore
    const txData = parseTransaction(transaction);
    const signedTx = {
        ...signature,
        ...txData,
    };
    // @ts-ignore
    return serializeTransaction(signedTx);
}

/**
 * Relays valid representation of signed transaction to Etherem mempool for execution.
 *
 * @param {TransactionWithSignature} tx - Signed Ethereum transaction.
 * @returns Hash of relayed transaction.
 */
export async function broadcastSignedTransaction(
    tx: TransactionWithSignature
): Promise<Hash> {
    const signedTx = addSignature(tx);
    return relaySignedTransaction(signedTx);
}

/**
 * Relays signed transaction to Ethereum mem-pool for execution.
 * @param serializedTransaction - Signed Ethereum transaction.
 * @returns Transaction Hash of relayed transaction.
 */
export async function relaySignedTransaction(
    serializedTransaction: Hex,
    wait: boolean = true
): Promise<Hash> {
    // @ts-ignore
    const tx = parseTransaction(serializedTransaction);
    const network = Network.fromChainId(tx.chainId!);
    if (wait) {
        // @ts-ignore
        const hash = await network.client.sendRawTransaction({
            serializedTransaction,
        });
        console.log(`Transaction Confirmed: ${network.scanUrl}/tx/${hash}`);
        return hash;
    } else {
        // @ts-ignore
        network.client.sendRawTransaction({
            serializedTransaction,
        });
        return keccak256(serializedTransaction);
    }
}


### lib/mpcUtils/kdf.ts ###
import { sha3_256 } from "js-sha3";
import { ec as EC } from "elliptic";
import { keccak256 } from "ethers";
import { base_decode } from "near-api-js/lib/utils/serialize";

export function najPublicKeyStrToUncompressedHexPoint(
    najPublicKeyStr: string
): string {
    const decodedKey = base_decode(najPublicKeyStr.split(":")[1]!);
    return "04" + Buffer.from(decodedKey).toString("hex");
}

export function deriveChildPublicKey(
    parentUncompressedPublicKeyHex: string,
    signerId: string,
    path: string = ""
): string {
    const ec = new EC("secp256k1");
    const scalarHex = sha3_256(
        `near-mpc-recovery v0.1.0 epsilon derivation:${signerId},${path}`
    );

    const x = parentUncompressedPublicKeyHex.substring(2, 66);
    const y = parentUncompressedPublicKeyHex.substring(66);

    // Create a point object from X and Y coordinates
    const oldPublicKeyPoint = ec.curve.point(x, y);

    // Multiply the scalar by the generator point G
    const scalarTimesG = ec.g.mul(scalarHex);

    // Add the result to the old public key point
    const newPublicKeyPoint = oldPublicKeyPoint.add(scalarTimesG);
    const newX = newPublicKeyPoint.getX().toString("hex").padStart(64, "0");
    const newY = newPublicKeyPoint.getY().toString("hex").padStart(64, "0");
    return "04" + newX + newY;
}

export function uncompressedHexPointToEvmAddress(uncompressedHexPoint: string) {
    const addressHash = keccak256(`0x${uncompressedHexPoint.slice(2)}`);
    // Ethereum address is last 20 bytes of hash (40 characters), prefixed with 0x
    return "0x" + addressHash.substring(addressHash.length - 40);
}


### lib/mpcUtils/utils.ts ###
export * from "./request";
export * from "./signature";
export * from "./transaction";

export { mockAdapter } from "./mock-sign";


### lib/mpcUtils/mockSign.ts ###
import { Hex, Signature, toHex } from "viem";

export function fromPayload(payload: number[]): Hex {
    if (payload.length !== 32) {
        throw new Error(`Payload must have 32 bytes: ${payload}`);
    }
    // Convert number[] back to Uint8Array
    return toHex(new Uint8Array(payload));
}

/**
 * Converts a raw hexadecimal signature into a structured Signature object
 * @param hexSignature The raw hexadecimal signature (e.g., '0x...')
 * @returns A structured Signature object with fields r, s, v, and yParity
 */
export function hexToSignature(hexSignature: Hex): Signature {
    // Strip "0x" prefix if it exists
    const cleanedHex = hexSignature.slice(2);

    // Ensure the signature is 65 bytes (130 hex characters)
    if (cleanedHex.length !== 130) {
        throw new Error(
            `Invalid hex signature length: ${cleanedHex.length}. Expected 130 characters (65 bytes).`
        );
    }

    // Extract the r, s, and v components from the hex signature
    const v = BigInt(`0x${cleanedHex.slice(128, 130)}`); // Last byte (2 hex characters)
    return {
        r: `0x${cleanedHex.slice(0, 64)}`, // First 32 bytes (64 hex characters)
        s: `0x${cleanedHex.slice(64, 128)}`, // Next 32 bytes (64 hex characters),
        v,
        // Determine yParity based on v (27 or 28 maps to 0 or 1)
        yParity: v === 27n ? 0 : v === 28n ? 1 : undefined,
    };
}


