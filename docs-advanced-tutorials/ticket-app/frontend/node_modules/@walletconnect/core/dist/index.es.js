import Pt,{EventEmitter as A}from"events";import he from"pino";import Ot from"@walletconnect/keyvaluestorage";import{HEARTBEAT_EVENTS as Y,HeartBeat as At}from"@walletconnect/heartbeat";import{generateChildLogger as f,getLoggerContext as w,getDefaultLoggerOptions as ce}from"@walletconnect/logger";import{IMessageTracker as zt,IPublisher as Nt,ISubscriber as Ut,IRelayer as Lt,IStore as Ft,IJsonRpcHistory as Mt,IExpirer as $t,ICore as Kt}from"@walletconnect/types";import{safeJsonStringify as kt,safeJsonParse as Bt}from"@walletconnect/safe-json";import*as K from"@walletconnect/relay-auth";import{getInternalError as c,mapToObj as ue,objToMap as le,generateKeyPair as jt,generateRandomBytes32 as J,deriveSymKey as Vt,hashKey as qt,validateEncoding as Gt,isTypeOneEnvelope as de,encrypt as Yt,validateDecoding as Jt,decrypt as Ht,deserialize as Xt,decodeTypeByte as Wt,hashMessage as k,getRelayProtocolName as H,getRelayProtocolApi as X,isUndefined as W,getSdkError as L,formatRelayRpcUrl as Zt,isProposalStruct as Qt,isSessionStruct as ei,TYPE_1 as ti,calcExpiry as Z,formatUri as ii,parseUri as si,createDelayedPromise as ri,engineEvent as Q,isExpired as ge,isValidParams as ee,isValidUrl as ni,isValidString as ai,parseExpirerTarget as oi,formatTopicTarget as hi,formatIdTarget as ci}from"@walletconnect/utils";import{ONE_DAY as z,SIX_HOURS as ui,ONE_SECOND as li,THIRTY_DAYS as te,FIVE_SECONDS as di,THIRTY_SECONDS as pe,Watch as gi,toMiliseconds as De,FIVE_MINUTES as ye}from"@walletconnect/time";import{JsonRpcProvider as pi}from"@walletconnect/jsonrpc-provider";import{isJsonRpcRequest as be,formatJsonRpcResult as Ee,formatJsonRpcRequest as me,formatJsonRpcError as Di,isJsonRpcResult as yi,isJsonRpcError as fe,isJsonRpcResponse as bi}from"@walletconnect/jsonrpc-utils";import Ei from"@walletconnect/jsonrpc-ws-connection";import mi from"lodash.isequal";function fi(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<r.length;s++){var n=r.charAt(s),a=n.charCodeAt(0);if(t[a]!==255)throw new TypeError(n+" is ambiguous");t[a]=s}var o=r.length,h=r.charAt(0),l=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function g(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var D=0,P=0,E=0,I=u.length;E!==I&&u[E]===0;)E++,D++;for(var C=(I-E)*d+1>>>0,y=new Uint8Array(C);E!==I;){for(var R=u[E],x=0,m=C-1;(R!==0||x<P)&&m!==-1;m--,x++)R+=256*y[m]>>>0,y[m]=R%o>>>0,R=R/o>>>0;if(R!==0)throw new Error("Non-zero carry");P=x,E++}for(var S=C-P;S!==C&&y[S]===0;)S++;for(var $=h.repeat(D);S<C;++S)$+=r.charAt(y[S]);return $}function M(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var D=0;if(u[D]!==" "){for(var P=0,E=0;u[D]===h;)P++,D++;for(var I=(u.length-D)*l+1>>>0,C=new Uint8Array(I);u[D];){var y=t[u.charCodeAt(D)];if(y===255)return;for(var R=0,x=I-1;(y!==0||R<E)&&x!==-1;x--,R++)y+=o*C[x]>>>0,C[x]=y%256>>>0,y=y/256>>>0;if(y!==0)throw new Error("Non-zero carry");E=R,D++}if(u[D]!==" "){for(var m=I-E;m!==I&&C[m]===0;)m++;for(var S=new Uint8Array(P+(I-m)),$=P;m!==I;)S[$++]=C[m++];return S}}}function G(u){var D=M(u);if(D)return D;throw new Error(`Non-${e} character`)}return{encode:g,decodeUnsafe:M,decode:G}}var wi=fi,vi=wi;const we=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Ii=r=>new TextEncoder().encode(r),Ci=r=>new TextDecoder().decode(r);class Ri{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class _i{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ve(this,e)}}class Si{constructor(e){this.decoders=e}or(e){return ve(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const ve=(r,e)=>new Si({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class Ti{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new Ri(e,t,i),this.decoder=new _i(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const B=({name:r,prefix:e,encode:t,decode:i})=>new Ti(r,e,t,i),F=({prefix:r,name:e,alphabet:t})=>{const{encode:i,decode:s}=vi(t,e);return B({prefix:r,name:e,encode:i,decode:n=>we(s(n))})},xi=(r,e,t,i)=>{const s={};for(let d=0;d<e.length;++d)s[e[d]]=d;let n=r.length;for(;r[n-1]==="=";)--n;const a=new Uint8Array(n*t/8|0);let o=0,h=0,l=0;for(let d=0;d<n;++d){const g=s[r[d]];if(g===void 0)throw new SyntaxError(`Non-${i} character`);h=h<<t|g,o+=t,o>=8&&(o-=8,a[l++]=255&h>>o)}if(o>=t||255&h<<8-o)throw new SyntaxError("Unexpected end of data");return a},Pi=(r,e,t)=>{const i=e[e.length-1]==="=",s=(1<<t)-1;let n="",a=0,o=0;for(let h=0;h<r.length;++h)for(o=o<<8|r[h],a+=8;a>t;)a-=t,n+=e[s&o>>a];if(a&&(n+=e[s&o<<t-a]),i)for(;n.length*t&7;)n+="=";return n},p=({name:r,prefix:e,bitsPerChar:t,alphabet:i})=>B({prefix:e,name:r,encode(s){return Pi(s,i,t)},decode(s){return xi(s,i,t,r)}}),Oi=B({prefix:"\0",name:"identity",encode:r=>Ci(r),decode:r=>Ii(r)});var Ai=Object.freeze({__proto__:null,identity:Oi});const zi=p({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Ni=Object.freeze({__proto__:null,base2:zi});const Ui=p({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Li=Object.freeze({__proto__:null,base8:Ui});const Fi=F({prefix:"9",name:"base10",alphabet:"0123456789"});var Mi=Object.freeze({__proto__:null,base10:Fi});const $i=p({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Ki=p({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var ki=Object.freeze({__proto__:null,base16:$i,base16upper:Ki});const Bi=p({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ji=p({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Vi=p({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),qi=p({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Gi=p({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Yi=p({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ji=p({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Hi=p({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Xi=p({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Wi=Object.freeze({__proto__:null,base32:Bi,base32upper:ji,base32pad:Vi,base32padupper:qi,base32hex:Gi,base32hexupper:Yi,base32hexpad:Ji,base32hexpadupper:Hi,base32z:Xi});const Zi=F({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Qi=F({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var es=Object.freeze({__proto__:null,base36:Zi,base36upper:Qi});const ts=F({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),is=F({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var ss=Object.freeze({__proto__:null,base58btc:ts,base58flickr:is});const rs=p({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ns=p({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),as=p({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),os=p({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var hs=Object.freeze({__proto__:null,base64:rs,base64pad:ns,base64url:as,base64urlpad:os});const Ie=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),cs=Ie.reduce((r,e,t)=>(r[t]=e,r),[]),us=Ie.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function ls(r){return r.reduce((e,t)=>(e+=cs[t],e),"")}function ds(r){const e=[];for(const t of r){const i=us[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const gs=B({prefix:"\u{1F680}",name:"base256emoji",encode:ls,decode:ds});var ps=Object.freeze({__proto__:null,base256emoji:gs}),Ds=Re,Ce=128,ys=127,bs=~ys,Es=Math.pow(2,31);function Re(r,e,t){e=e||[],t=t||0;for(var i=t;r>=Es;)e[t++]=r&255|Ce,r/=128;for(;r&bs;)e[t++]=r&255|Ce,r>>>=7;return e[t]=r|0,Re.bytes=t-i+1,e}var ms=ie,fs=128,_e=127;function ie(r,i){var t=0,i=i||0,s=0,n=i,a,o=r.length;do{if(n>=o)throw ie.bytes=0,new RangeError("Could not decode varint");a=r[n++],t+=s<28?(a&_e)<<s:(a&_e)*Math.pow(2,s),s+=7}while(a>=fs);return ie.bytes=n-i,t}var ws=Math.pow(2,7),vs=Math.pow(2,14),Is=Math.pow(2,21),Cs=Math.pow(2,28),Rs=Math.pow(2,35),_s=Math.pow(2,42),Ss=Math.pow(2,49),Ts=Math.pow(2,56),xs=Math.pow(2,63),Ps=function(r){return r<ws?1:r<vs?2:r<Is?3:r<Cs?4:r<Rs?5:r<_s?6:r<Ss?7:r<Ts?8:r<xs?9:10},Os={encode:Ds,decode:ms,encodingLength:Ps},Se=Os;const Te=(r,e,t=0)=>(Se.encode(r,e,t),e),xe=r=>Se.encodingLength(r),se=(r,e)=>{const t=e.byteLength,i=xe(r),s=i+xe(t),n=new Uint8Array(s+t);return Te(r,n,0),Te(t,n,i),n.set(e,s),new As(r,t,e,n)};class As{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const Pe=({name:r,code:e,encode:t})=>new zs(r,e,t);class zs{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?se(this.code,t):t.then(i=>se(this.code,i))}else throw Error("Unknown type, must be binary type")}}const Oe=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),Ns=Pe({name:"sha2-256",code:18,encode:Oe("SHA-256")}),Us=Pe({name:"sha2-512",code:19,encode:Oe("SHA-512")});var Ls=Object.freeze({__proto__:null,sha256:Ns,sha512:Us});const Ae=0,Fs="identity",ze=we,Ms=r=>se(Ae,ze(r)),$s={code:Ae,name:Fs,encode:ze,digest:Ms};var Ks=Object.freeze({__proto__:null,identity:$s});new TextEncoder,new TextDecoder;const Ne={...Ai,...Ni,...Li,...Mi,...ki,...Wi,...es,...ss,...hs,...ps};({...Ls,...Ks});function ks(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(r):new Uint8Array(r)}function Ue(r,e,t,i){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:i}}}const Le=Ue("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),re=Ue("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=ks(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),Bs={utf8:Le,"utf-8":Le,hex:Ne.base16,latin1:re,ascii:re,binary:re,...Ne};function js(r,e="utf8"){const t=Bs[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(r,"utf8"):t.decoder.decode(`${t.prefix}${r}`)}const ne="wc",Fe=2,j="core",T=`${ne}@${2}:${j}:`,Me={name:j,logger:"error"},$e={database:":memory:"},Ke="crypto",ae="client_ed25519_seed",ke=z,Be="keychain",je="0.3",Ve="messages",qe="0.3",Ge=ui,Ye="publisher",Je="irn",He="error",Xe="wss://relay.walletconnect.com",We="relayer",N={message:"relayer_message",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error"},Ze="_subscription",O={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},Qe=li,Vs={database:":memory:"},et="2.1.3",tt="0.3",_={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},qs=te,it="subscription",st="0.3",rt=di*1e3,nt="pairing",at="0.3",Gs=te,U={wc_pairingDelete:{req:{ttl:z,prompt:!1,tag:1e3},res:{ttl:z,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:pe,prompt:!1,tag:1002},res:{ttl:pe,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:z,prompt:!1,tag:0},res:{ttl:z,prompt:!1,tag:0}}},v={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},ot="history",ht="0.3",ct="expirer",b={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},ut="0.3",Ys=z;class lt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=Be,this.version=je,this.initialized=!1,this.storagePrefix=T,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:n}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(n)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()},this.core=e,this.logger=f(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,ue(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?le(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class dt{constructor(e,t,i){this.core=e,this.logger=t,this.name=Ke,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),n=K.generateKeyPair(s);return K.encodeIss(n.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=jt();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const n=await this.getClientSeed(),a=K.generateKeyPair(n),o=J(),h=ke;return await K.signJWT(o,s,h,a)},this.generateSharedKey=(s,n,a)=>{this.isInitialized();const o=this.getPrivateKey(s),h=Vt(o,n);return this.setSymKey(h,a)},this.setSymKey=async(s,n)=>{this.isInitialized();const a=n||qt(s);return await this.keychain.set(a,s),a},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s)},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s)},this.encode=async(s,n,a)=>{this.isInitialized();const o=Gt(a),h=kt(n);if(de(o)){const M=o.senderPublicKey,G=o.receiverPublicKey;s=await this.generateSharedKey(M,G)}const l=this.getSymKey(s),{type:d,senderPublicKey:g}=o;return Yt({type:d,symKey:l,message:h,senderPublicKey:g})},this.decode=async(s,n,a)=>{this.isInitialized();const o=Jt(n,a);if(de(o)){const d=o.receiverPublicKey,g=o.senderPublicKey;s=await this.generateSharedKey(d,g)}const h=this.getSymKey(s),l=Ht({symKey:h,encoded:n});return Bt(l)},this.core=e,this.logger=f(t,this.name),this.keychain=i||new lt(this.core,this.logger)}get context(){return w(this.logger)}getPayloadType(e){const t=Xt(e);return Wt(t.type)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(ae)}catch{e=J(),await this.keychain.set(ae,e)}return js(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class gt extends zt{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=Ve,this.version=qe,this.initialized=!1,this.storagePrefix=T,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}},this.set=async(i,s)=>{this.isInitialized();const n=k(s);let a=this.messages.get(i);return typeof a>"u"&&(a={}),typeof a[n]<"u"||(a[n]=s,this.messages.set(i,a),await this.persist()),n},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();const n=this.get(i),a=k(s);return typeof n[a]<"u"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist()},this.logger=f(e,this.name),this.core=t}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,ue(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?le(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Js extends Nt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new A,this.name=Ye,this.queue=new Map,this.publish=async(i,s,n)=>{this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}});try{const a=n?.ttl||Ge,o=H(n),h=n?.prompt||!1,l=n?.tag||0,d={topic:i,message:s,opts:{ttl:a,relay:o,prompt:h,tag:l}},g=k(s);this.queue.set(g,d),await this.rpcPublish(i,s,a,o,h,l),this.onPublish(g,d),this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}})}catch(a){throw this.logger.debug("Failed to Publish Payload"),this.logger.error(a),a}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=f(t,this.name),this.registerEventListeners()}get context(){return w(this.logger)}rpcPublish(e,t,i,s,n,a){var o,h,l,d;const g={method:X(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:n,tag:a}};return W((o=g.params)==null?void 0:o.prompt)&&((h=g.params)==null||delete h.prompt),W((l=g.params)==null?void 0:l.tag)&&((d=g.params)==null||delete d.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:g}),this.relayer.provider.request(g)}onPublish(e,t){this.queue.delete(e)}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:i,opts:{ttl:s,relay:n,prompt:a,tag:o}}=e,h=k(i);await this.rpcPublish(t,i,s,n,a,o),this.onPublish(h,e)})}registerEventListeners(){this.relayer.core.heartbeat.on(Y.pulse,()=>{this.checkQueue()})}}class Hs{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(n=>n!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var Xs=Object.defineProperty,Ws=Object.defineProperties,Zs=Object.getOwnPropertyDescriptors,pt=Object.getOwnPropertySymbols,Qs=Object.prototype.hasOwnProperty,er=Object.prototype.propertyIsEnumerable,Dt=(r,e,t)=>e in r?Xs(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,V=(r,e)=>{for(var t in e||(e={}))Qs.call(e,t)&&Dt(r,t,e[t]);if(pt)for(var t of pt(e))er.call(e,t)&&Dt(r,t,e[t]);return r},oe=(r,e)=>Ws(r,Zs(e));class yt extends Ut{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new Hs,this.events=new A,this.name=it,this.version=st,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pendingSubInterval=20,this.storagePrefix=T,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restart(),this.registerEventListeners(),this.onEnable())},this.subscribe=async(i,s)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const n=H(s),a={topic:i,relay:n};this.pending.set(i,a);const o=await this.rpcSubscribe(i,n);return this.onSubscribe(o,a),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}}),o}catch(n){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(n),n}},this.unsubscribe=async(i,s)=>{this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)},this.isSubscribed=async i=>this.topics.includes(i)?!0:await new Promise((s,n)=>{const a=new gi;a.start(this.pendingSubscriptionWatchLabel);const o=setInterval(()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),s(!0)),a.elapsed(this.pendingSubscriptionWatchLabel)>=rt&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),n(!1))},this.pendingSubInterval)}),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.restart=async()=>{await this.restore(),await this.reset()},this.relayer=e,this.logger=f(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear(),this.initialized=!1}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=H(i);await this.rpcUnsubscribe(e,t,s);const n=L("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,n),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:X(t.protocol).subscribe,params:{topic:e}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i}),await this.relayer.provider.request(i)}rpcUnsubscribe(e,t,i){const s={method:X(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.provider.request(s)}onSubscribe(e,t){this.setSubscription(e,oe(V({},t),{id:e})),this.pending.delete(t.topic)}onResubscribe(e,t){this.addSubscription(e,oe(V({},t),{id:e})),this.pending.delete(t.topic)}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t))}addSubscription(e,t){this.subscriptions.set(e,V({},t)),this.topicMap.set(t.topic,e),this.events.emit(_.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(_.deleted,oe(V({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(_.sync)}async reset(){this.cached.length&&await Promise.all(this.cached.map(async e=>await this.resubscribe(e))),this.events.emit(_.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async resubscribe(e){if(!this.ids.includes(e.id)){const{topic:t,relay:i}=e,s={topic:t,relay:i};this.pending.set(s.topic,s);const n=await this.rpcSubscribe(s.topic,s.relay);this.onResubscribe(n,s)}}async onConnect(){await this.restart(),this.onEnable()}onDisconnect(){this.onDisable()}checkPending(){this.relayer.transportExplicitlyClosed||this.pending.forEach(async e=>{const t=await this.rpcSubscribe(e.topic,e.relay);this.onSubscribe(t,e)})}registerEventListeners(){this.relayer.core.heartbeat.on(Y.pulse,()=>{this.checkPending()}),this.relayer.provider.on(O.connect,async()=>{await this.onConnect()}),this.relayer.provider.on(O.disconnect,()=>{this.onDisconnect()}),this.events.on(_.created,async e=>{const t=_.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}),this.events.on(_.deleted,async e=>{const t=_.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}var tr=Object.defineProperty,bt=Object.getOwnPropertySymbols,ir=Object.prototype.hasOwnProperty,sr=Object.prototype.propertyIsEnumerable,Et=(r,e,t)=>e in r?tr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,rr=(r,e)=>{for(var t in e||(e={}))ir.call(e,t)&&Et(r,t,e[t]);if(bt)for(var t of bt(e))sr.call(e,t)&&Et(r,t,e[t]);return r};class mt extends Lt{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new A,this.name=We,this.transportExplicitlyClosed=!1,this.initialized=!1,this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?f(e.logger,this.name):he(ce({level:e.logger||He})),this.messages=new gt(this.logger,e.core),this.subscriber=new yt(this,this.logger),this.publisher=new Js(this,this.logger),this.relayUrl=e?.relayUrl||Xe,this.projectId=e.projectId,this.provider={}}async init(){this.logger.trace("Initialized"),this.provider=await this.createProvider(),await Promise.all([this.messages.init(),this.provider.connect(),this.subscriber.init()]),this.registerEventListeners(),this.initialized=!0}get context(){return w(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t})}async subscribe(e,t){return this.isInitialized(),await this.subscriber.subscribe(e,t)}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportClose(){this.transportExplicitlyClosed=!0,await this.provider.disconnect()}async transportOpen(e){this.relayUrl=e||this.relayUrl,this.transportExplicitlyClosed=!1,await this.provider.connect(),await new Promise(t=>{this.subscriber.once(_.resubscribed,()=>{t()})})}async createProvider(){const e=await this.core.crypto.signJWT(this.relayUrl);return new pi(new Ei(Zt({sdkVersion:et,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e})))}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;return await this.subscriber.isSubscribed(t)?this.messages.has(t,i):!0}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),be(e)){if(!e.method.endsWith(Ze))return;const t=e.params,{topic:i,message:s}=t.data,n={topic:i,message:s};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(rr({type:"event",event:t.id},n)),this.events.emit(t.id,n),await this.acknowledgePayload(e),await this.onMessageEvent(n)}}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(N.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=Ee(e.id,!0);await this.provider.connection.send(t)}registerEventListeners(){this.provider.on(O.payload,e=>this.onProviderPayload(e)),this.provider.on(O.connect,()=>{this.events.emit(N.connect)}),this.provider.on(O.disconnect,()=>{this.events.emit(N.disconnect),this.attemptToReconnect()}),this.provider.on(O.error,e=>this.events.emit(N.error,e))}attemptToReconnect(){this.transportExplicitlyClosed||setTimeout(()=>{this.provider.connect()},De(Qe))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}var nr=Object.defineProperty,ft=Object.getOwnPropertySymbols,ar=Object.prototype.hasOwnProperty,or=Object.prototype.propertyIsEnumerable,wt=(r,e,t)=>e in r?nr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,vt=(r,e)=>{for(var t in e||(e={}))ar.call(e,t)&&wt(r,t,e[t]);if(ft)for(var t of ft(e))or.call(e,t)&&wt(r,t,e[t]);return r};class It extends Ft{constructor(e,t,i,s=T,n=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=tt,this.cached=[],this.initialized=!1,this.storagePrefix=T,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(a=>{Qt(a)?this.map.set(a.id,a):ei(a)?this.map.set(a.topic,a):this.getKey&&a!==null&&!W(a)&&this.map.set(this.getKey(a),a)}),this.cached=[],this.initialized=!0)},this.set=async(a,o)=>{this.isInitialized(),this.map.has(a)?await this.update(a,o):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:a,value:o}),this.map.set(a,o),await this.persist())},this.get=a=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:a}),this.getData(a)),this.getAll=a=>(this.isInitialized(),a?this.values.filter(o=>Object.keys(a).every(h=>mi(o[h],a[h]))):this.values),this.update=async(a,o)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:a,update:o});const h=vt(vt({},this.getData(a)),o);this.map.set(a,h),await this.persist()},this.delete=async(a,o)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:a,reason:o}),this.map.delete(a),await this.persist())},this.logger=f(t,this.name),this.storagePrefix=s,this.getKey=n}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Ct{constructor(e,t){this.core=e,this.logger=t,this.name=nt,this.version=at,this.events=new Pt,this.initialized=!1,this.storagePrefix=T,this.ignoredPayloadTypes=[ti],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]},this.create=async()=>{this.isInitialized();const i=J(),s=await this.core.crypto.setSymKey(i),n=Z(ye),a={protocol:Je},o={topic:s,expiry:n,relay:a,active:!1},h=ii({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:a});return await this.pairings.set(s,o),await this.core.relayer.subscribe(s),this.core.expirer.set(s,n),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:n,relay:a}=si(i.uri),o=Z(ye),h={topic:s,relay:a,expiry:o,active:!1};return await this.pairings.set(s,h),await this.core.crypto.setSymKey(n,s),await this.core.relayer.subscribe(s,{relay:a}),this.core.expirer.set(s,o),i.activatePairing&&await this.activate({topic:s}),h},this.activate=async({topic:i})=>{this.isInitialized();const s=Z(te);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s)},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const n=await this.sendRequest(s,"wc_pairingPing",{}),{done:a,resolve:o,reject:h}=ri();this.events.once(Q("pairing_ping",n),({error:l})=>{l?h(l):o()}),await a()}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",L("USER_DISCONNECTED")),await this.deletePairing(s))},this.sendRequest=async(i,s,n)=>{const a=me(s,n),o=await this.core.crypto.encode(i,a),h=U[s].req;return this.core.history.set(i,a),await this.core.relayer.publish(i,o,h),a.id},this.sendResult=async(i,s,n)=>{const a=Ee(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),l=U[h.request.method].res;await this.core.relayer.publish(s,o,l),await this.core.history.resolve(a)},this.sendError=async(i,s,n)=>{const a=Di(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),l=U[h.request.method]?U[h.request.method].res:U.unregistered_method.res;await this.core.relayer.publish(s,o,l),await this.core.history.resolve(a)},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,L("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])},this.cleanup=async()=>{const i=this.pairings.getAll().filter(s=>ge(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))},this.onRelayEventRequest=i=>{const{topic:s,payload:n}=i;switch(n.method){case"wc_pairingPing":return this.onPairingPingRequest(s,n);case"wc_pairingDelete":return this.onPairingDeleteRequest(s,n);default:return this.onUnknownRpcMethodRequest(s,n)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:n}=i,a=(await this.core.history.get(s,n.id)).request.method;switch(a){case"wc_pairingPing":return this.onPairingPingResponse(s,n);default:return this.onUnknownRpcMethodResponse(a)}},this.onPairingPingRequest=async(i,s)=>{const{id:n}=s;try{this.isValidPing({topic:i}),await this.sendResult(n,i,!0),this.events.emit("pairing_ping",{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onPairingPingResponse=(i,s)=>{const{id:n}=s;setTimeout(()=>{yi(s)?this.events.emit(Q("pairing_ping",n),{}):fe(s)&&this.events.emit(Q("pairing_ping",n),{error:s.error})},500)},this.onPairingDeleteRequest=async(i,s)=>{const{id:n}=s;try{this.isValidDisconnect({topic:i}),await this.sendResult(n,i,!0),await this.deletePairing(i),this.events.emit("pairing_delete",{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:n,method:a}=s;try{if(this.registeredMethods.includes(a))return;const o=L("WC_METHOD_UNSUPPORTED",a);await this.sendError(n,i,o),this.logger.error(o)}catch(o){await this.sendError(n,i,o),this.logger.error(o)}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(L("WC_METHOD_UNSUPPORTED",i))},this.isValidPair=i=>{if(!ee(i)){const{message:s}=c("MISSING_OR_INVALID",`pair() params: ${i}`);throw new Error(s)}if(!ni(i.uri)){const{message:s}=c("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw new Error(s)}},this.isValidPing=async i=>{if(!ee(i)){const{message:n}=c("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidDisconnect=async i=>{if(!ee(i)){const{message:n}=c("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidPairingTopic=async i=>{if(!ai(i,!1)){const{message:s}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(ge(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=c("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=f(t,this.name),this.pairings=new It(this.core,this.logger,this.name,this.storagePrefix)}get context(){return w(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(N.message,async e=>{const{topic:t,message:i}=e;if(this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);be(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):bi(s)&&(await this.core.history.resolve(s),this.onRelayEventResponse({topic:t,payload:s}))})}registerExpirerEvents(){this.core.expirer.on(b.expired,async e=>{const{topic:t}=oi(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit("pairing_expire",{topic:t}))})}}class Rt extends Mt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new A,this.name=ot,this.version=ht,this.cached=[],this.initialized=!1,this.storagePrefix=T,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(i,s,n)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:n}),this.records.has(s.id))return;const a={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:n};this.records.set(a.id,a),this.events.emit(v.created,a)},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=fe(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(v.updated,s))},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(n=>{if(n.topic===i){if(typeof s<"u"&&n.id!==s)return;this.records.delete(n.id),this.events.emit(v.deleted,n)}})},this.exists=async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=f(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:me(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(v.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(v.created,e=>{const t=v.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(v.updated,e=>{const t=v.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(v.deleted,e=>{const t=v.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class _t extends $t{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new A,this.name=ct,this.version=ut,this.cached=[],this.initialized=!1,this.storagePrefix=T,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}},this.set=(i,s)=>{this.isInitialized();const n=this.formatTarget(i),a={target:n,expiry:s};this.expirations.set(n,a),this.checkExpiry(n,a),this.events.emit(b.created,{target:n,expiration:a})},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{this.isInitialized();const s=this.formatTarget(i);if(this.has(s)){const n=this.getExpiration(s);this.expirations.delete(s),this.events.emit(b.deleted,{target:s,expiration:n})}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=f(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return hi(e);if(typeof e=="number")return ci(e);const{message:t}=c("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(b.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;De(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(b.expired,{target:e,expiration:t})}checkExpirations(){this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(Y.pulse,()=>this.checkExpirations()),this.events.on(b.created,e=>{const t=b.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(b.expired,e=>{const t=b.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(b.deleted,e=>{const t=b.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}var hr=Object.defineProperty,St=Object.getOwnPropertySymbols,cr=Object.prototype.hasOwnProperty,ur=Object.prototype.propertyIsEnumerable,Tt=(r,e,t)=>e in r?hr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,xt=(r,e)=>{for(var t in e||(e={}))cr.call(e,t)&&Tt(r,t,e[t]);if(St)for(var t of St(e))ur.call(e,t)&&Tt(r,t,e[t]);return r};class q extends Kt{constructor(e){super(e),this.protocol=ne,this.version=Fe,this.name=j,this.events=new A,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId;const t=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:he(ce({level:e?.logger||Me.logger}));this.logger=f(t,this.name),this.heartbeat=new At,this.crypto=new dt(this,this.logger,e?.keychain),this.history=new Rt(this,this.logger),this.expirer=new _t(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new Ot(xt(xt({},$e),e?.storageOptions)),this.relayer=new mt({core:this,logger:this.logger,relayUrl:e?.relayUrl,projectId:this.projectId}),this.pairing=new Ct(this,this.logger)}static async init(e){const t=new q(e);return await t.initialize(),t}get context(){return w(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initilization Success")}catch(e){throw this.logger.warn(`Core Initilization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const lr=q;export{j as CORE_CONTEXT,Me as CORE_DEFAULT,ne as CORE_PROTOCOL,$e as CORE_STORAGE_OPTIONS,T as CORE_STORAGE_PREFIX,Fe as CORE_VERSION,ae as CRYPTO_CLIENT_SEED,Ke as CRYPTO_CONTEXT,ke as CRYPTO_JWT_TTL,lr as Core,dt as Crypto,ct as EXPIRER_CONTEXT,Ys as EXPIRER_DEFAULT_TTL,b as EXPIRER_EVENTS,ut as EXPIRER_STORAGE_VERSION,_t as Expirer,ot as HISTORY_CONTEXT,v as HISTORY_EVENTS,ht as HISTORY_STORAGE_VERSION,Rt as JsonRpcHistory,Be as KEYCHAIN_CONTEXT,je as KEYCHAIN_STORAGE_VERSION,lt as KeyChain,Ve as MESSAGES_CONTEXT,qe as MESSAGES_STORAGE_VERSION,gt as MessageTracker,nt as PAIRING_CONTEXT,Gs as PAIRING_DEFAULT_TTL,U as PAIRING_RPC_OPTS,at as PAIRING_STORAGE_VERSION,rt as PENDING_SUB_RESOLUTION_TIMEOUT,Ye as PUBLISHER_CONTEXT,Ge as PUBLISHER_DEFAULT_TTL,Ct as Pairing,We as RELAYER_CONTEXT,He as RELAYER_DEFAULT_LOGGER,Je as RELAYER_DEFAULT_PROTOCOL,Xe as RELAYER_DEFAULT_RELAY_URL,N as RELAYER_EVENTS,O as RELAYER_PROVIDER_EVENTS,Qe as RELAYER_RECONNECT_TIMEOUT,et as RELAYER_SDK_VERSION,Vs as RELAYER_STORAGE_OPTIONS,Ze as RELAYER_SUBSCRIBER_SUFFIX,mt as Relayer,tt as STORE_STORAGE_VERSION,it as SUBSCRIBER_CONTEXT,qs as SUBSCRIBER_DEFAULT_TTL,_ as SUBSCRIBER_EVENTS,st as SUBSCRIBER_STORAGE_VERSION,It as Store,yt as Subscriber,q as default};
//# sourceMappingURL=index.es.js.map
